def generalUtil
def jsUtil
def mainBranches = ['main', 'master']

pipeline {
    agent any

    tools { nodejs 'Node' }

    parameters {
        string(name: 'PR_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_DESTINATION_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_REPO_HTML', defaultValue: '', description: '')
        string(name: 'PR_COMMIT', defaultValue: '', description: '')
        string(name: 'PR_PROJECT', defaultValue: '', description: '')
        string(name: 'PR_STATE', defaultValue: '', description: '')
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                [key: 'PR_BRANCH', value: '$.pullrequest.source.branch.name'],
                [key: 'PR_DESTINATION_BRANCH', value: '$.pullrequest.destination.branch.name'],
                [key: 'PR_REPO_HTML', value: '$.repository.links.self.href'],
                [key: 'PR_COMMIT', value: '$.pullrequest.source.commit.hash'],
                [key: 'PR_PROJECT', value: '$.repository.full_name'],
                [key: 'PR_STATE', value: '$.pullrequest.state']
            ],

            tokenCredentialId: 'trigger-token',
            regexpFilterText: '$PR_STATE',
            regexpFilterExpression: 'MERGED'
        )
    }

    environment {
        CI_PIPELINE = 'false'
        PROJECT_TYPE = 'JS_Project'
        PROJECT_DIR = "${env.WORKSPACE}/${PROJECT_TYPE}"
        REPORT_DIR = "${env.WORKSPACE}/DeploymentJob"
        JOB_REPO = "${PR_REPO_HTML}"
        BITBUCKET_ACCESS_TOKEN = credentials('bitbucket-access-token')
        DESTINATION_BRANCH = "${PR_DESTINATION_BRANCH}"

        // Environmental variables for static analysis
        SONARQUBE_SERVER = 'SonarServer'
        SONARQUBE_SCANNER = 'sonarqube-scanner'
        SONAR_PROJECT_KEY = "${env.JOB_NAME.split('/')[0]}-Deployment"
    }

    stages {
        // Deletes the cloned branch from the build machine after it has been merged into main.
        // This prevents the build machine's storage from capping out.
        stage('Delete Merged Branch') {
            steps {
                script {
                    // Aborts the pipeline if it's not merging into the main.
                    if (!mainBranches.contains(DESTINATION_BRANCH)) {
                        env.FAILURE_REASON = 'Not merging to the main branch. Exiting the pipeline...'
                        currentBuild.result = 'ABORTED'
                        error(env.FAILURE_REASON)
                    }

                    generalUtil = load("${env.WORKSPACE}/groovy/generalHelper.groovy")
                    jsUtil = load("${env.WORKSPACE}/groovy/jsHelper.groovy")

                    def branch_path = sh(script: "/usr/bin/find ../ -type d -name \"${PR_BRANCH}\"", returnStdout: true)
                    branch_path = branch_path.trim()
                    if (!branch_path.isEmpty()) {
                        sh "rm -r -f \"${branch_path}\""
                        sh "rm -r -f \"${branch_path}@tmp\""
                    }

                    env.FOLDER_NAME = "${JOB_NAME}".split('/').first()
                    def ticketNumber = generalUtil.parseTicketNumber(PR_BRANCH)
                    generalUtil.cleanMergedBranchReportsFromWebServer(FOLDER_NAME, ticketNumber)
                }
            }
        }
        // Prepares the WORKSPACE for the build by cleaning the project, pulling main, and then telling Bitbucket that the
        // build is in progress. It also checks to see if the project's Unity version is downloaded, and installs it if not.
        stage('Prepare WORKSPACE') {
            environment {
                REPO_SSH = "git@bitbucket.org:${PR_PROJECT}.git"
            }
            steps {
                script {
                    // Getting the full commit hash from git in order to send the build status to Bitbucket.
                    script {
                        env.COMMIT_HASH = generalUtil.getFullCommitHash(env.WORKSPACE, PR_COMMIT)
                    }
                    if (!fileExists("${PROJECT_DIR}")) {
                        echo 'First time running pipeline. Cloning main branch...'
                        sh "git clone ${REPO_SSH} \"${PROJECT_DIR}\""
                    }
                }

                dir("${PROJECT_DIR}") {
                    // Ensure it stays in the main branch
                    echo 'Checkout to the main branch...'
                    sh "git checkout ${DESTINATION_BRANCH}"
                    echo 'Cleaning project...'
                    sh 'git reset --hard HEAD'
                    echo 'Pulling latest version of default branch...'
                    sh 'git pull'
                }

                script {
                    echo "Sending \'In Progress\' status to Bitbucket..."
                    generalUtil.sendBuildStatus(env.WORKSPACE, 'INPROGRESS', COMMIT_HASH)
                    env.TEST_DIRECTORIES = jsUtil.findTestingDirs(PROJECT_DIR)
                    echo "Testing directories: ${env.TEST_DIRECTORIES}"
                }
            }
        }
        stage('Install Dependencies') {
            steps {
                script {
                    //MUST USE BAT for npm commands, otherwise jenkins tries to use WSL for a linux distro
                    echo 'Dependencies step'
                    echo 'Check NPM'

                    sh 'node -v'
                    sh 'npm -v'
                    sh 'npm config ls'

                    echo 'Install dependencies in testing directories'
                    jsUtil.installNpmInTestingDirs(env.TEST_DIRECTORIES)

                    // Change back to default directory
                    sh(script: 'cd "' + env.WORKSPACE + '"')
                }
            }
        }
        //linting stage to check formatting
        stage('Linting')
        {
            steps {
                dir("${REPORT_DIR}") {
                    sh 'mkdir -p linting_results'
                }
                script {
                    echo 'Linting step'
                    jsUtil.executeLintingInTestingDirs(env.TEST_DIRECTORIES, false) //* Set the deploymentBuild argument as "false" for now
                }
            }
        }
        // Runs the project's EditMode tests, and then generates a test report and a code coverage report.
        // Sends the test results to Bitbucket once the tests complete.
        stage('Unit Testing') {
            steps {
                script {
                    echo 'Unit testing step'
                    echo 'Run unit testing in testing directories'
                    jsUtil.runUnitTestsInTestingDirs(env.TEST_DIRECTORIES, false) //* Set the deploymentBuild argument as "false" for now

                    // Change back to default directory
                    sh(script: 'cd "' + env.WORKSPACE + '"')
                }
            }
        }
        // Runs static code analysis using SonarQube installed in Jenkins virtual machine.
        stage('Static Analysis') {
            steps {
                dir("${PROJECT_DIR}") {
                    script {
                        sh 'pwd'
                        String scannerHome = tool 'sonarqube-scanner'
                        echo "SonarQube scanner located at: ${scannerHome}"

                        withSonarQubeEnv(SONARQUBE_SERVER) {
                            String sonarCommand = "\"${scannerHome}/bin/sonar-scanner\" " +
                                                "\"-Dsonar.projectKey=${env.SONAR_PROJECT_KEY}\" " +
                                                '\"-Dsonar.host.url=http://localhost:9000/sonarqube\" ' +
                                                '\"-Dsonar.sources=.\" ' +
                                                '\"-Dsonar.python.version=3.10\"'

                            echo "Executing SonarQube scanner with command: ${sonarCommand}"
                            sh sonarCommand
                        }
                    }
                }
                withCredentials([string(credentialsId: 'SonarQube', variable: 'SONAR_QUBE_AUTH_TOKEN')]) {
                    script {
                        Map status = jsUtil.checkQualityGateStatus(SONAR_PROJECT_KEY , env.SONAR_QUBE_AUTH_TOKEN)

                        catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                            if ((status.entireCodeStatus != 'OK') && (status.newCodeStatus != 'OK')) {
                                error('Quality gate failed!')
                            } else {
                                echo 'Quality gate passed!'
                            }
                        }
                    }
                }
            }
        }
        // Check the Docker and Azure conneciton
        stage('Check Build and Deploy Condition') {
            steps {
                script {
                    // Check whether the Docker is running or not
                    int isDockerRunning = sh(script: 'sudo docker info > /dev/null 2>&1', returnStatus: true)
                    echo "isDockerRunning: ${isDockerRunning}"

                    if (isDockerRunning != 0) {
                        echo 'Docker is not running or not available.'
                        error('Docker is not available. Please start Docker and try again.')
                    }
                }

                script {
                    // Login to Azure using system managed identity
                    sh 'sudo az login --identity --username 0ca5eb7b-0dfc-4449-8c1e-c9dae95c7a97'

                    // Login to Azure Container Registry
                    try {
                        sh 'sudo az acr login --name webbuilds'
                        echo 'Successfully logged in to Azure Container Registry.'
                    } catch (Exception e) {
                        echo 'Failed to login to Azure Container Registry.'
                        error('Pipeline terminated: Azure Container Registry login failed.')
                    }
                }
            }
        }
        // Deploys the server and client container to Azure Container Registry(acr) and updates container apps
        stage('Server Build and Deploy') {
            // Skip this step if 'SERVER_SOURCE_FOLDER' parameter isn't provided
            when {
                expression { params.SERVER_SOURCE_FOLDER?.trim() }
            }
            steps {
                script {
                    // Retreive versions of server container images from Azure container registry
                    def server_latest_version = sh(
                        script: "sudo az acr repository show-tags --name webbuilds --repository ${params.SERVER_CONTAINER_NAME} --output tsv | grep -v \"latest\" | sort -V | tail -n 1",
                        returnStdout: true
                    ).trim()
                    echo "The latest server container version on ACR: ${server_latest_version}"

                    // Read container's version number from each server package.json
                    echo 'Get the version of each container image'
                    def project_server_version = ''
                    dir("${PROJECT_DIR}/${params.SERVER_SOURCE_FOLDER}") {
                        // Read the version value of package.json using Node.js.
                        project_server_version = sh(
                            script: "node -p \"require('./package.json').version\"",
                            returnStdout: true
                        ).trim()

                        if (project_server_version == '') {
                            error('Failed to read Server version...')
                        }
                        echo "Server Project Version: ${project_server_version}"

                        // Check whether the server version in up-to-date
                        catchError(buildResult: 'UNSTABLE', stageResult: 'UNSTABLE') {
                            if (!jsUtil.versionCompare(server_latest_version, project_server_version)) {
                                warnError('Server version is not up to date. Skipping the deployment process.')
                                currentBuild.result = 'UNSTABLE'
                                return // Skip server deployment process
                            }
                            echo 'Server version is up-to-date. Proceeding with deployment.'
                            String projectDir = env.PROJECT_DIR.replace('\\', '/')
                            // Build server container image
                            echo 'Build The Server Container Image'
                            sh "sudo docker build -t ${env.AZ_CONTAINER_REGISTRY_NAME}/${params.SERVER_CONTAINER_NAME}:${project_server_version} ${projectDir}/${params.SERVER_SOURCE_FOLDER}/."

                            // Push server container to the Azure Container Registry
                            echo 'Push The Server Container Image to Azure Container Registry'
                            sh "sudo docker push ${env.AZ_CONTAINER_REGISTRY_NAME}/${params.SERVER_CONTAINER_NAME}:${project_server_version}"

                            // Update server instance from Azure Container App
                            echo 'Update The Server Container App to the Latest Version'
                            sh "sudo az containerapp update --name ${params.SERVER_CONTAINER_NAME} --resource-group ${params.AZ_RESOURCE_GROUP} --image ${env.AZ_CONTAINER_REGISTRY_NAME}/${params.SERVER_CONTAINER_NAME}:${project_server_version}"

                            // Clean up local images
                            echo 'Delete The Server Container'
                            sh "sudo docker rmi ${env.AZ_CONTAINER_REGISTRY_NAME}/${params.SERVER_CONTAINER_NAME}:${project_server_version}"
                        }
                    }
                }
            }
        }

        stage('Client Build and Deploy') {
            // Skip this step if 'CLIENT_SOURCE_FOLDER' parameter isn't provided
            when {
                expression { params.CLIENT_SOURCE_FOLDER?.trim() }
            }
            steps {
                script {
                    // Retreive versions of client container from Azure container registry
                    def client_latest_version = sh(
                        script: "sudo az acr repository show-tags --name webbuilds --repository ${params.CLIENT_CONTAINER_NAME} --output tsv | grep -v \"latest\" | sort -V | tail -n 1",
                        returnStdout: true
                    ).trim()
                    echo "The latest client container version on ACR: ${client_latest_version}"

                    // Read container's version number from client package.json
                    echo 'Get the version of each container image'
                    def project_client_version = ''
                    dir("${PROJECT_DIR}/${params.CLIENT_SOURCE_FOLDER}") {
                        // Read the version value of package.json using Node.js.
                        project_client_version = sh(
                            script: "node -p \"require('./package.json').version\"",
                            returnStdout: true
                        ).trim()

                        if (project_client_version == '') {
                            error('Failed to read Client version...')
                        }
                        echo "Client Project Version: ${project_client_version}"

                        // Check whether the client version in up-to-date
                        catchError(buildResult: 'UNSTABLE', stageResult: 'UNSTABLE') {
                            if (!jsUtil.versionCompare(client_latest_version, project_client_version)) {
                                warnError('Client version is not up to date. Skipping the deployment process.')
                                currentBuild.result = 'UNSTABLE'
                                return // Skip client deployment process
                            }
                            echo 'Client version is up-to-date. Proceeding with deployment.'

                            String projectDir = env.PROJECT_DIR.replace('\\', '/')
                            // Build client container image
                            echo 'Build The Client Container Image'
                            sh "sudo docker build -t ${env.AZ_CONTAINER_REGISTRY_NAME}/${params.CLIENT_CONTAINER_NAME}:${project_client_version} ${projectDir}/${params.CLIENT_SOURCE_FOLDER}/."

                            // Push client container to the Azure Container Registry
                            echo 'Push The Client Container Image to Azure Container Registry'
                            sh "sudo docker push ${env.AZ_CONTAINER_REGISTRY_NAME}/${params.CLIENT_CONTAINER_NAME}:${project_client_version}"

                            // Update client instance from Azure Container App
                            echo 'Update The Client Container App to the Latest Version'
                            sh "sudo az containerapp update --name ${params.CLIENT_CONTAINER_NAME} --resource-group ${params.AZ_RESOURCE_GROUP} --image ${env.AZ_CONTAINER_REGISTRY_NAME}/${params.CLIENT_CONTAINER_NAME}:${project_client_version}"

                            // Clean up local images
                            echo 'Delete The Client Container Image'
                            sh "sudo docker rmi ${env.AZ_CONTAINER_REGISTRY_NAME}/${params.CLIENT_CONTAINER_NAME}:${project_client_version}"
                        }
                    }
                }
            }
        }
    }

    // Sends the build status to Bitbucket. If the build was successful, Bitbucket will link to the deployed project on the web server.
    post {
        always {
            script {
                echo 'Returning to the main branch...'
                generalUtil.checkoutBranch(PROJECT_DIR, DESTINATION_BRANCH)
            }
        }
        success {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'SUCCESSFUL', COMMIT_HASH, true, true)
            }
        }
        failure {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'FAILED', COMMIT_HASH, true, true)
            }
        }
        aborted {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'STOPPED', COMMIT_HASH, true, true)
            }
        }
    }
}
