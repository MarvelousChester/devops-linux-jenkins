def generalUtil
def jsUtil

pipeline {
    agent any

    tools {
        nodejs 'Node'
    }

    parameters {
        string(name: 'PR_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_DESTINATION_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_REPO_HTML', defaultValue: '', description: '')
        string(name: 'PR_REPO_NAME', defaultValue: '', description: '')
        string(name: 'PR_COMMIT', defaultValue: '', description: '')
        string(name: 'PR_PROJECT', defaultValue: '', description: '')
        string(name: 'PR_STATE', defaultValue: '', description: '')
        string(name: 'TEST_RUN', defaultValue: '', description: 'This is a test run trigger. Fill in the parameter form with \'Y\' to run the pipeline without commit changes.')
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                [key: 'PR_BRANCH', value: '$.pullrequest.source.branch.name'],
                [key: 'PR_DESTINATION_BRANCH', value: '$.pullrequest.destination.branch.name'],
                [key: 'PR_REPO_HTML', value: '$.repository.links.self.href'],
                [key: 'PR_REPO_NAME', value: '$.repository.name'],
                [key: 'PR_COMMIT', value: '$.pullrequest.source.commit.hash'],
                [key: 'PR_PROJECT', value: '$.repository.full_name'],
                [key: 'PR_STATE', value: '$.pullrequest.state']
            ],

            tokenCredentialId: 'trigger-token',
            regexpFilterText: '$PR_STATE',
            regexpFilterExpression: 'OPEN'
        )
    }

    environment {
        CI_PIPELINE = 'true'
        PROJECT_TYPE = 'JS_Project'
        PROJECT_DIR = "${env.WORKSPACE}/${PROJECT_TYPE}"
        REPORT_DIR = "${env.WORKSPACE}/PRJob/${PR_BRANCH}/Build_${BUILD_NUMBER}"
        JOB_REPO = "${PR_REPO_HTML}"
        BITBUCKET_ACCESS_TOKEN = credentials('bitbucket-access-token')
        // JENKINS_API_KEY = credentials('jenkins-api-key')
        REPO_SSH = "git@bitbucket.org:${PR_PROJECT}.git"
        DESTINATION_BRANCH = "${PR_DESTINATION_BRANCH}"

        // Environmental variables for static analysis
        SONARQUBE_SERVER = 'SonarServer'
        SONARQUBE_SCANNER = 'sonarqube-scanner'
        SONAR_PROJECT_KEY = "${env.JOB_NAME.split('/')[0]}-PR"
    }

    stages {
        // Prepare WORKSPACE: Environment Setup, WORKSPACE Preparation(Branch Management), Unity Setup, Initial running the project on Unity Editor
        stage('Prepare WORKSPACE') {
            steps {
                dir("${PROJECT_DIR}") {
                    //send 'In Progress' status to Bitbucket
                    script {
                        // print jenkins env configurations
                        sh 'env'
                        generalUtil = load("${env.WORKSPACE}/groovy/generalHelper.groovy")
                        jsUtil = load("${env.WORKSPACE}/groovy/jsHelper.groovy")

                        if (generalUtil.isBranchUpToDateWithRemote(PR_BRANCH)) {
                            echo "Current branch is up-to-date with origin/${destinationBranch}. Aborting pipeline."
                            currentBuild.result = 'ABORTED'
                            error('Branch is up to date, no changes.')
                        }

                        env.COMMIT_HASH = generalUtil.getFullCommitHash(env.WORKSPACE, PR_COMMIT)

                        echo 'initialize environment'
                        generalUtil.initializeEnvironment(env.WORKSPACE, env.COMMIT_HASH, PR_BRANCH)

                        echo 'clone Or Update Repo'
                        generalUtil.cloneOrUpdateRepo(PROJECT_TYPE, env.WORKSPACE, PROJECT_DIR, REPO_SSH, PR_BRANCH)

                        echo 'merge Branch If Needed'
                        generalUtil.mergeBranchIfNeeded()

                        // Save directories pipeline is going to test. unique to JS pipeline
                        echo 'find Testing Dirs'
                        env.TEST_DIRECTORIES = jsUtil.findTestingDirs(PROJECT_DIR)
                        echo "Testing directories: ${env.TEST_DIRECTORIES}"
                    }
                }
            }
        }
        stage('Install Dependencies') {
            steps {
                script {
                    //MUST USE BAT for npm commands, otherwise jenkins tries to use WSL for a linux distro
                    echo 'Dependencies step'
                    echo 'Check NPM'

                    jsUtil.checkNodeVersion()

                    echo 'Install dependencies in testing directories'
                    jsUtil.installNpmInTestingDirs(env.TEST_DIRECTORIES)

                    // Change back to default directory
                    sh(script: 'cd "' + env.WORKSPACE + '"')
                }
            }
        }
        stage('Linting') {
            steps {
                dir("${REPORT_DIR}") {
                    sh 'mkdir -p linting_results'
                }
                script {
                    echo 'Linting step'
                    jsUtil.executeLintingInTestingDirs(env.TEST_DIRECTORIES, false)
                }
            }
        }
        // Runs the project's EditMode tests, and then generates a test report and a code coverage report.
        // Sends the test results to Bitbucket once the tests complete.
        stage('Unit Testing') {
            steps {
                script {
                    echo 'Unit testing step'
                    echo 'Run unit testing in testing directories'
                    jsUtil.runUnitTestsInTestingDirs(env.TEST_DIRECTORIES, false)

                    // Change back to default directory
                    sh(script: 'cd "' + env.WORKSPACE + '"')
                }
            }
        }
        // Runs static code analysis using SonarQube installed in Jenkins virtual machine.
        stage('Static Analysis') {
            steps {
                dir("${PROJECT_DIR}") {
                    script {
                        sh 'pwd'
                        String scannerHome = tool 'sonarqube-scanner'
                        echo "SonarQube scanner located at: ${scannerHome}"

                        withSonarQubeEnv(SONARQUBE_SERVER) {
                            String sonarCommand = "\"${scannerHome}/bin/sonar-scanner\" " +
                                                "\"-Dsonar.projectKey=${env.SONAR_PROJECT_KEY}\" " +
                                                '\"-Dsonar.host.url=http://localhost:9000/sonarqube\" ' +
                                                '\"-Dsonar.sources=.\" '  +
                                                '\"-Dsonar.python.version=3.10\"'

                            echo "Executing SonarQube scanner with command: ${sonarCommand}"
                            sh sonarCommand
                        }
                    }
                }
                withCredentials([string(credentialsId: 'SonarQube', variable: 'SONAR_QUBE_AUTH_TOKEN')]) {
                    script {
                        Map status = jsUtil.checkQualityGateStatus(SONAR_PROJECT_KEY , env.SONAR_QUBE_AUTH_TOKEN)

                        catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                            if ((status.entireCodeStatus != 'OK') && (status.newCodeStatus != 'OK')) {
                                error('Quality gate failed!')
                        } else {
                                echo 'Quality gate passed!'
                            }
                        }
                    }
                }
            }
        }
    }

    // When the pipeline finishes, sends the build status to Bitbucket.
    post {
        always {
            script {
                echo 'Returning to the main branch...'
                generalUtil.checkoutBranch(PROJECT_DIR, DESTINATION_BRANCH)
            }
        }
        success {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'SUCCESSFUL', env.COMMIT_HASH, false, true)
            }
        }
        failure {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'FAILED', env.COMMIT_HASH, false, true)
            }
        }
        aborted {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'STOPPED', env.COMMIT_HASH, false, true)
            }
        }
    }
}
