def generalUtil
def jsUtil

pipeline {
    agent any

    tools {
        nodejs 'Node'
    }

    parameters {
        string(name: 'PR_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_DESTINATION_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_REPO_HTML', defaultValue: '', description: '')
        string(name: 'PR_REPO_NAME', defaultValue: '', description: '')
        string(name: 'PR_COMMIT', defaultValue: '', description: '')
        string(name: 'PR_PROJECT', defaultValue: '', description: '')
        string(name: 'PR_STATE', defaultValue: '', description: '')
        string(name: 'TEST_RUN', defaultValue: '',
        description: 'This is a test run trigger. Fill in the parameter form with \'Y\' to run the pipeline without commit changes.')
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                /* groovylint-disable DuplicateStringLiteral */
                [key: 'PR_BRANCH', value: '$.pullrequest.source.branch.name'],
                [key: 'PR_DESTINATION_BRANCH', value: '$.pullrequest.destination.branch.name'],
                [key: 'PR_REPO_HTML', value: '$.repository.links.self.href'],
                [key: 'PR_REPO_NAME', value: '$.repository.name'],
                [key: 'PR_COMMIT', value: '$.pullrequest.source.commit.hash'],
                [key: 'PR_PROJECT', value: '$.repository.full_name'],
                [key: 'PR_STATE', value: '$.pullrequest.state']
                /* groovylint-enable DuplicateStringLiteral */
            ],

            tokenCredentialId: 'trigger-token',
            regexpFilterText: '$PR_STATE',
            regexpFilterExpression: 'OPEN'
        )
    }

    environment {
        CI_PIPELINE = 'true'
        PROJECT_TYPE = 'JS_Project'
        PROJECT_DIR = "${env.WORKSPACE}/${PROJECT_TYPE}"
        REPORT_DIR = "${env.WORKSPACE}/PRJob/${PR_BRANCH}/Build_${BUILD_NUMBER}"
        JOB_REPO = "${PR_REPO_HTML}"
        BITBUCKET_ACCESS_TOKEN = credentials('bitbucket-access-token')
        // JENKINS_API_KEY = credentials('jenkins-api-key')
        REPO_SSH = "git@bitbucket.org:${PR_PROJECT}.git"
        DESTINATION_BRANCH = "${PR_DESTINATION_BRANCH}"

        // Environmental variables for static analysis
        SONARQUBE_SERVER = 'SonarServer'
        SONARQUBE_SCANNER = 'sonarqube-scanner'
        SONAR_PROJECT_KEY = "${env.JOB_NAME.split('/')[0]}-PR"
    }

    stages {
        // Prepare WORKSPACE: Environment Setup, WORKSPACE Preparation(Branch Management),
        //  Unity Setup, Initial running the project on Unity Editor
        stage('Prepare WORKSPACE') {
            steps {
                dir("${PROJECT_DIR}") {
                    //send 'In Progress' status to Bitbucket
                    script {
                        // print jenkins env configurations
                        sh 'env'
                        generalUtil = load("${env.WORKSPACE}/groovy/generalHelper.groovy")
                        jsUtil = load("${env.WORKSPACE}/groovy/jsHelper.groovy")

                        if (generalUtil.isBranchUpToDateWithRemote(PR_BRANCH)) {
                            echo "Current branch is up-to-date with origin/${destinationBranch}. Aborting pipeline."
                            currentBuild.result = 'ABORTED'
                            error('Branch is up to date, no changes.')
                        }

                        COMMIT_HASH = generalUtil.getFullCommitHash(env.WORKSPACE, PR_COMMIT)

                        echo 'initialize environment'
                        generalUtil.initializeEnvironment(env.WORKSPACE, COMMIT_HASH, PR_BRANCH)

                        echo 'clone Or Update Repo'
                        generalUtil.cloneOrUpdateRepo(PROJECT_TYPE, env.WORKSPACE, PROJECT_DIR, REPO_SSH, PR_BRANCH)

                        echo 'merge Branch If Needed'
                        generalUtil.mergeBranchIfNeeded()

                        // Save directories pipeline is going to test. unique to JS pipeline
                        echo 'find Testing Dirs'
                        env.TEST_DIRECTORIES = jsUtil.findTestingDirs(PROJECT_DIR)
                        echo "Testing directories: ${env.TEST_DIRECTORIES}"
                    }
                }
            }
        }
        stage('Install Dependencies') {
            steps {
                script {
                    //MUST USE BAT for npm commands, otherwise jenkins tries to use WSL for a linux distro
                    echo 'Dependencies step'
                    echo 'Check NPM'

                    jsUtil.checkNodeVersion()

                    echo 'Install dependencies in testing directories'
                    jsUtil.installNpmInTestingDirs(env.TEST_DIRECTORIES)

                    // Change back to default directory
                    sh(script: 'cd "' + env.WORKSPACE + '"')
                }
            }
        }
        stage('Linting') {
            steps {
                dir("${REPORT_DIR}") {
                    sh 'mkdir -p linting_results'
                }
                script {
                    echo 'Linting step'
                    jsUtil.executeLintingInTestingDirs(env.TEST_DIRECTORIES, false)
                }
            }
        }
        // Runs the project's EditMode tests, and then generates a test report and a code coverage report.
        // Sends the test results to Bitbucket once the tests complete.
        stage('Unit Testing') {
            steps {
                script {
                    echo 'Unit testing step'
                    echo 'Run unit testing in testing directories'
                    jsUtil.runUnitTestsInTestingDirs(env.TEST_DIRECTORIES, false)

                    // Change back to default directory
                    // groovylint-disable-next-line DuplicateStringLiteral
                    sh(script: 'cd "' + env.WORKSPACE + '"')
                }

                script {
                    skipMessage = 'Skip report sending process...'
                    echo 'Publish test results html to dlx-webhost server...'
                    generalUtil.publishTestResultsHtmlToWebServer(
                        FOLDER_NAME, TICKET_NUMBER,
                        "${PROJECT_DIR}/${params.SERVER_SOURCE_FOLDER}/coverage/${params.SERVER_SOURCE_FOLDER}/lcov-report",
                         'server')
                    generalUtil.publishTestResultsHtmlToWebServer(
                        FOLDER_NAME, TICKET_NUMBER,
                        "${PROJECT_DIR}/${params.CLIENT_SOURCE_FOLDER}/coverage/${params.CLIENT_SOURCE_FOLDER}/lcov-report",
                        'client')

                    echo 'Retrieve file paths of test summary JSON files'
                    final String COVERAGE_SUMMARY_FILE_NAME = 'coverage-summary.json'
                    final String TEST_SUMMARY_FILE_NAME = 'test-results.json'

                    // Processing the sending Bitbucket Coverage report
                    // Check whether project has a server-side codes or not
                    if (params.SERVER_SOURCE_FOLDER?.trim()) {
                        // Retrive paths of server-side test summary files
                        Map serverTestSummaryDirs = jsUtil.retrieveReportSummaryDirs(
                            "${env.PROJECT_DIR}/${params.SERVER_SOURCE_FOLDER?.trim() ?: ''}",
                            COVERAGE_SUMMARY_FILE_NAME,
                            TEST_SUMMARY_FILE_NAME
                        )

                        // Check the return value
                        // groovylint-disable-next-line InvertedIfElse
                        if (!serverTestSummaryDirs.isEmpty()) {
                            /* groovylint-disable DuplicateStringLiteral */
                            echo 'Server-side summary files are founded.'
                            echo "Coverage Summary Path: ${serverTestSummaryDirs['coverageSummaryDir']}"
                            echo "Test Summary Path: ${serverTestSummaryDirs['testSummaryDir']}"

                            echo 'Send the server-side coverage report to Bitbucket'
                            String cmdArgs = " ${COMMIT_HASH}" +
                                             " ${serverTestSummaryDirs['coverageSummaryDir']}" +
                                             " ${serverTestSummaryDirs['testSummaryDir']}" +
                                             ' --server'

                            // Pass '--debug' flag to create_bitbucket_coverage_report.py when a developer enable 'DEBUG_MODE'
                            if ((params.DEBUG_MODE ?: '').toUpperCase() == 'Y') {
                                cmdArgs += ' --debug'
                                echo "cmdArgs: ${cmdArgs}"
                            }

                            sh " python python/create_bitbucket_coverage_report.py ${cmdArgs}"
                            /* groovylint-enable DuplicateStringLiteral */
                        }
                        else {
                            echo 'Server-side summary files are not founded.'
                            echo skipMessage
                        }
                    }
                    else {
                        echo 'params.SERVER_SOURCE_FOLDER is not founded...'
                        echo skipMessage
                    }

                    // Check whether project has a client-side codes or not
                    if (params.CLIENT_SOURCE_FOLDER?.trim()) {
                        // Retrive paths of server-side test summary files
                        Map clientTestSummaryDirs = jsUtil.retrieveReportSummaryDirs(
                            "${env.PROJECT_DIR}/${params.CLIENT_SOURCE_FOLDER?.trim() ?: ''}",
                            COVERAGE_SUMMARY_FILE_NAME,
                            TEST_SUMMARY_FILE_NAME
                        )

                        // Check the return value
                        // groovylint-disable-next-line InvertedIfElse
                        if (!clientTestSummaryDirs.isEmpty()) {
                            /* groovylint-disable DuplicateStringLiteral */
                            echo 'Client-side summary files are founded.'
                            echo "Coverage Summary Path: ${clientTestSummaryDirs['coverageSummaryDir']}"
                            echo "Test Summary Path: ${clientTestSummaryDirs['testSummaryDir']}"

                            String cmdArgs =
                                " ${COMMIT_HASH}" +
                                " ${clientTestSummaryDirs['coverageSummaryDir']}" +
                                " ${clientTestSummaryDirs['testSummaryDir']}" +
                                ' --client'
                            // Pass '--debug' flag to create_bitbucket_coverage_report.py when a developer enable 'DEBUG_MODE'
                            if ((params.DEBUG_MODE ?: '').toUpperCase() == 'Y') {
                                cmdArgs += ' --debug'
                                echo "cmdArgs: ${cmdArgs}"
                            }

                            sh " python python/create_bitbucket_coverage_report.py ${cmdArgs}"
                            /* groovylint-enable DuplicateStringLiteral */
                        }
                        else {
                            echo 'Client-side summary files are not founded.'
                            echo skipMessage
                        }
                    }
                    else {
                        echo 'params.CLIENT_SOURCE_FOLDER is not founded...'
                        echo skipMessage
                    }
                }
            }
        }
        // Runs static code analysis using SonarQube installed in Jenkins virtual machine.
        stage('Static Analysis') {
            steps {
                dir("${PROJECT_DIR}") {
                    script {
                        sh 'pwd'
                        String scannerHome = tool SONARQUBE_SCANNER
                        echo "SonarQube scanner located at: ${scannerHome}"

                        withSonarQubeEnv(SONARQUBE_SERVER) {
                            String sonarCommand = "\"${scannerHome}/bin/sonar-scanner\" " +
                                                "\"-Dsonar.projectKey=${env.SONAR_PROJECT_KEY}\" " +
                                                '\"-Dsonar.host.url=http://localhost:9000/sonarqube\" ' +
                                                '\"-Dsonar.sources=.\" '  +
                                                '\"-Dsonar.python.version=3.10\"'

                            echo "Executing SonarQube scanner with command: ${sonarCommand}"
                            sh sonarCommand
                        }
                    }
                }
                withCredentials([string(credentialsId: 'SonarQube', variable: 'SONAR_QUBE_AUTH_TOKEN')]) {
                    script {
                        Map status = jsUtil.checkQualityGateStatus(SONAR_PROJECT_KEY , env.SONAR_QUBE_AUTH_TOKEN)

                        catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                            // groovylint-disable-next-line DuplicateStringLiteral
                            if ((status.entireCodeStatus != 'OK') && (status.newCodeStatus != 'OK')) {
                                error('Quality gate failed!')
                        } else {
                                echo 'Quality gate passed!'
                            }
                        }
                    }
                }
            }
        }
    }

    // When the pipeline finishes, sends the build status to Bitbucket.
    post {
        always {
            script {
                echo 'Returning to the main branch...'
                currentBuild.description = "${PR_BRANCH}"
                generalUtil.checkoutBranch(PROJECT_DIR, DESTINATION_BRANCH)
            }
        }
        success {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'SUCCESSFUL', COMMIT_HASH, false)
            }
        }
        failure {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'FAILED', COMMIT_HASH, false)
            }
        }
        aborted {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'STOPPED', COMMIT_HASH, false)
            }
        }
    }
}
