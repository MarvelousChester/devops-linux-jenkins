def pass = 'Pass'
def fail = 'Fail'
def generalUtil
def unityUtil

pipeline {
    agent any

    tools {
        dotnetsdk 'dotnet-8'
    }

    parameters {
        string(name: 'PR_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_DESTINATION_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_REPO_HTML', defaultValue: '', description: '')
        string(name: 'PR_REPO_NAME', defaultValue: '', description: '')
        string(name: 'PR_COMMIT', defaultValue: '', description: '')
        string(name: 'PR_PROJECT', defaultValue: '', description: '')
        string(name: 'PR_STATE', defaultValue: '', description: '')
        string(name: 'TEST_RUN', defaultValue: '', description: 'This is a test run trigger. Fill in the parameter form with \'Y\' to run the pipeline without commit changes.')
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                [key: 'PR_BRANCH', value: '$.pullrequest.source.branch.name'],
                [key: 'PR_DESTINATION_BRANCH', value: '$.pullrequest.destination.branch.name'],
                [key: 'PR_REPO_HTML', value: '$.repository.links.self.href'],
                [key: 'PR_REPO_NAME', value: '$.repository.name'],
                [key: 'PR_COMMIT', value: '$.pullrequest.source.commit.hash'],
                [key: 'PR_PROJECT', value: '$.repository.full_name'],
                [key: 'PR_STATE', value: '$.pullrequest.state']
            ],

            tokenCredentialId: 'trigger-token',
            regexpFilterText: '$PR_STATE',
            regexpFilterExpression: 'OPEN'
        )
    }

    environment {
        CI_PIPELINE = 'true'
        PROJECT_TYPE = 'Unity_Project'
        PROJECT_DIR = "${env.WORKSPACE}/${PROJECT_TYPE}"
        REPORT_DIR = "${env.WORKSPACE}/PRJob/${PR_BRANCH}"
        JOB_REPO = "${PR_REPO_HTML}"
        BITBUCKET_ACCESS_TOKEN = credentials('bitbucket-access-token')
        JENKINS_API_KEY = credentials('jenkins-api-key')
        REPO_SSH = "git@bitbucket.org:${PR_PROJECT}.git"
        DESTINATION_BRANCH = "${PR_DESTINATION_BRANCH}"
    }

    stages {
        // Prepare WORKSPACE: Environment Setup, env.WORKSPACE Preparation(Branch Management), Unity Setup, Initial running the project on Unity Editor
        stage('Prepare WORKSPACE') {
            steps {
                dir ("${PROJECT_DIR}") {
                //send 'In Progress' status to Bitbucket
                    script {
                        // print jenkins env configurations
                        sh 'env'
                        try {
                            generalUtil = load("${env.WORKSPACE}/groovy/generalHelper.groovy")
                            unityUtil = load("${env.WORKSPACE}/groovy/unityHelper.groovy")
                        } catch (Exception e) {
                            error "Failed to load Groovy scripts: ${e.message}"
                        }

                        
                        if(generalUtil.isBranchUpToDateWithRemote(PR_BRANCH) && !TEST_RUN.equals("Y")){
                            echo "Local branch commit is up to date with remote branch, no changes. Aborting pipeline."
                            currentBuild.result = 'ABORTED'
                            error("Branch is up to date, no changes.")                     
                        }

                        COMMIT_HASH = generalUtil.getFullCommitHash(env.WORKSPACE, PR_COMMIT)

                        generalUtil.initializeEnvironment(env.WORKSPACE, COMMIT_HASH, PR_BRANCH)

                        generalUtil.cloneOrUpdateRepo(PROJECT_TYPE, env.WORKSPACE, PROJECT_DIR, REPO_SSH, PR_BRANCH)

                        generalUtil.mergeBranchIfNeeded()
                    }
                }

                // Unity Setup: Identify the version of Unity Editor for the project
                echo 'Identifying Unity version...'
                script {
                    env.UNITY_EXECUTABLE = unityUtil.getUnityExecutable(env.WORKSPACE, PROJECT_DIR)
                }

                // Initial running the project on Unity Editor
                echo 'Running Unity in batch mode to setup initial files...'
                dir("${PROJECT_DIR}") {
                    script {
                        env.UNITY_EXECUTABLE = unityUtil.getUnityExecutable(env.WORKSPACE, PROJECT_DIR)
                    }

                    // Initial running the project on Unity Editor    
                    echo "Running Unity in batch mode to setup initial files..."
                    script {
                        String stageName = "Rider"
                        String errorMassage = "Synchronizing Unity and Rider IDE solution files failed"
                        unityUtil.runUnityStage(stageName, errorMassage)
                    }
                }
            }
        }
        stage('Linting') {
            steps {
                //Linting
                dir("${REPORT_DIR}") {
                    sh 'mkdir -p linting_results'
                }
                echo 'running lint script'
                script {
                    sh "cp -f \'${env.WORKSPACE}/Bash/.editorconfig\' \'${PROJECT_DIR}\' 2>/dev/null"
                    echo "Parameters for bash: ${env.WORKSPACE}/Linting.bash ${PROJECT_DIR} ${REPORT_DIR}"
                    def exitCode = sh script: "sh \'${env.WORKSPACE}/Bash/Linting.bash\' \'${PROJECT_DIR}\' \'${REPORT_DIR}/linting_results\'", returnStatus: true
                    echo "After bash call, exit code: ${exitCode}"
                    //handle exit code here
                    if (exitCode != 0) {
                        echo 'Error linting calling report'
                        echo "Parameters for Python Fail: \'${env.WORKSPACE}/python/linting_error_report.py\' \'${REPORT_DIR}/linting_results/format-report.json\' ${COMMIT_HASH} ${fail} \'${PROJECT_DIR}\'"

                        if (exitCode == 2) {
                            //report was generated call python script {
                            sh script: "python \'${env.WORKSPACE}/python/linting_error_report.py\' \'${REPORT_DIR}/linting_results/format-report.json\' ${COMMIT_HASH} ${fail} \'${PROJECT_DIR}\'"
                        }

                        catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                            error("Linting failed with exit code: ${exitCode}") //we exit no matter what on error code != 0
                        }
                    }
                    else{
                        echo "Parameters for Python Pass: \'${env.WORKSPACE}/python/linting_error_report.py\' \'${REPORT_DIR}/linting_results/format-report.json\' ${COMMIT_HASH} ${pass} \'${PROJECT_DIR}\'"
                        sh script: "python \'${env.WORKSPACE}/python/linting_error_report.py\' \'${REPORT_DIR}/linting_results/format-report.json\' ${COMMIT_HASH} ${pass} \'${PROJECT_DIR}\'"
                    }
                }
            }
        }

        // Runs the project's EditMode tests, and then generates a test report and a code coverage report.
        // Sends the test results to Bitbucket once the tests complete.
        stage('EditMode Tests') {
            steps {
                dir("${REPORT_DIR}") {
                    sh 'mkdir -p test_results'
                    sh 'mkdir -p coverage_results'
                }
                echo 'Running EditMode tests...'
                dir("${PROJECT_DIR}") {
                    script {
                        String stageName = "EditMode"
                        String errorMassage = "EditMode tests failed"
                        unityUtil.runUnityStage(stageName, errorMassage)
                    }
                }
            }
        }
        // Runs the project's PlayMode tests, and then generates a code coverage report.
        // PlayMode tests need to be run once in the editor to generate the overall coverage report.
        stage('PlayMode Tests in Editor') {
            steps {
                echo "Running PlayMode tests in Editor environment..."
                dir ("${PROJECT_DIR}") {
                    script {
                        String stageName = "PlayMode"
                        String errorMassage = "PlayMode tests failed"
                        unityUtil.runUnityStage(stageName, errorMassage) 
                    }
                }
            }
        }
        // Merges the two coverage reports from the EditMode and PlayMode (editor) reports into one.
        // Then sends a coverage report to Bitbucket.
        stage('Code Coverage\nSend Reports') {
            steps {
                dir("${PROJECT_DIR}") {
                    echo "Generating code coverage report..."
                    script {
                        String stageName = "Coverage"
                        String errorMassage = "Code Coverage generation failed"
                        unityUtil.runUnityStage(stageName, errorMassage) 
                    }


                    echo "Sending test report to Bitbucket."
                    script {
                        //publish results to web server
                        generalUtil.publishTestResultsHtmlToWebServer(FOLDER_NAME, TICKET_NUMBER, "${REPORT_DIR}/coverage_results/Report", 'CodeCoverage')
                        unityUtil.sendTestReport(env.WORKSPACE, REPORT_DIR, COMMIT_HASH)
                    }
                }

            }
        }
        //Builds the project and saves it.
        stage('Build Project') {
            steps {
                script {
                    echo "Building Unity project..."
                    //The following line assumed this folder exists in every project, adding check to ensure it does.
                    sh "mkdir -p \"${PROJECT_DIR}/Assets/Editor/\"" 
                    sh "cp Builder.cs \"${PROJECT_DIR}/Assets/Editor/\""

                    String stageName = "Webgl"
                    String errorMassage = "WebGL Build failed"
                    unityUtil.runUnityStage(stageName, errorMassage) 
                }
            }
        }
        }

    // When the pipeline finishes, sends the build status to Bitbucket.
    post {
        always {
            script {
                echo 'Returning to the main branch...'
                generalUtil.checkoutBranch(PROJECT_DIR, DESTINATION_BRANCH)
                currentBuild.description = "${PR_BRANCH}"
            }
        }
        success {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'SUCCESSFUL', COMMIT_HASH)
            }
        }
        failure {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'FAILED', COMMIT_HASH)
            }
        }
        aborted {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'STOPPED', COMMIT_HASH)
            }
        }
    }
}
