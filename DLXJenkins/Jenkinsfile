import groovy.transform.Field

@Field
def pass = 'Pass'
@Field
def fail = 'Fail'
@Field
def sharedLib
@Field
def generalUtil
@Field
def unityUtil
@Field
def resultStatus
@Field
def COMMIT_HASH

def prepareWorkSpace(){
    dir("${env.PROJECT_DIR}") {
    //send 'In Progress' status to Bitbucket
        script {
            // print jenkins env configurations
            sh 'env'
            try {
                // Load the necessary packages
                resultStatus = sharedLib.resource.ResultStatus

                generalUtil = load("${env.WORKSPACE}/groovy/generalHelper.groovy")
                unityUtil = load("${env.WORKSPACE}/groovy/unityHelper.groovy")

                if (generalUtil.isBranchUpToDateWithRemote(params.PR_BRANCH) && !params.TEST_RUN.equals('Y')) {
                    echo 'Local branch commit is up to date with remote branch, no changes. Aborting pipeline.'
                    currentBuild.result = resultStatus.BUILD_STATUS.ABORTED
                    error('Branch is up to date, no changes.')
                }

                COMMIT_HASH = generalUtil.getFullCommitHash(env.WORKSPACE, params.PR_COMMIT)

                generalUtil.initializeEnvironment(env.WORKSPACE, COMMIT_HASH, params.PR_BRANCH)

                generalUtil.cloneOrUpdateRepo(env.PROJECT_TYPE, env.WORKSPACE, env.PROJECT_DIR, env.REPO_SSH, params.PR_BRANCH)

                generalUtil.mergeBranchIfNeeded()
            } catch (Exception e) {
                error "Failed for Prepare WORKSPACE: ${e.message}"
            }
        }
    }

    // Unity Setup: Identify the version of Unity Editor for the project
    echo 'Identifying Unity version...'
    script {
        env.UNITY_EXECUTABLE = unityUtil.getUnityExecutable(env.WORKSPACE, env.PROJECT_DIR)
    }

    // Initial running the project on Unity Editor
    echo 'Running Unity in batch mode to setup initial files...'
    dir("${env.PROJECT_DIR}") {
        script {
            env.UNITY_EXECUTABLE = unityUtil.getUnityExecutable(env.WORKSPACE, env.PROJECT_DIR)
        }

        script {
            String stageName = 'Rider'
            String errorMassage = 'Synchronizing Unity and Rider IDE solution files failed'
            unityUtil.runUnityStage(stageName, errorMassage)
        }
    }
}

def runLinting() {
    dir("${env.REPORT_DIR}") {
        sh 'mkdir -p linting_results'
    }
    
    echo 'running lint script'
    script {
        try {
            sh "cp -f \'${env.WORKSPACE}/Bash/.editorconfig\' \'${env.PROJECT_DIR}\' 2>/dev/null"
            echo "Parameters for bash: ${env.WORKSPACE}/Linting.bash ${env.PROJECT_DIR} ${env.REPORT_DIR}"
            def exitCode = sh script: """ sh \'${env.WORKSPACE}/Bash/Linting.bash\' \\
                \'${env.PROJECT_DIR}\' \'${env.REPORT_DIR}/linting_results\'""", returnStatus: true
            echo "After bash call, exit code: ${exitCode}"
            //handle exit code here
            if (exitCode != 0) {
                echo 'Error linting calling report'
                echo """ Parameters for Python Fail: \\
                    \'${env.WORKSPACE}/python/linting_error_report.py\' \\
                    \'${env.REPORT_DIR}/linting_results/format-report.json\' \\
                    ${COMMIT_HASH} ${fail} \'${env.PROJECT_DIR}\'
                    
                """
                if (exitCode == 2) {
                    //report was generated call python script {
                    sh script: """python \'${env.WORKSPACE}/python/linting_error_report.py\' \\
                        \'${env.REPORT_DIR}/linting_results/format-report.json\' \\
                        ${COMMIT_HASH} ${fail} \'${env.PROJECT_DIR}\'
                        """
                    }

                catchError(buildResult: resultStatus.BUILD_STATUS.SUCCESS, stageResult: resultStatus.STAGE_STATUS.FAILURE) {
                    error("Linting failed with exit code: ${exitCode}") //we exit no matter what on error code != 0
                }
            }
            else {
                echo """ Parameters for Python Pass: \\
                    \'${env.WORKSPACE}/python/linting_error_report.py\' \\
                    \'${env.REPORT_DIR}/linting_results/format-report.json\' \\
                    ${COMMIT_HASH} ${pass} \'${env.PROJECT_DIR}\'
                """
                sh script: """python \\
                \'${env.WORKSPACE}/python/linting_error_report.py\' \\
                \'${env.REPORT_DIR}/linting_results/format-report.json\' \\
                ${COMMIT_HASH} ${pass} \'${env.PROJECT_DIR}\'
                """
            }
        }catch (Exception e) {
                error "Failed for Prepare WORKSPACE: ${e.message}"
        }
    }
}


def editModeTests() {
    dir("${env.REPORT_DIR}") {
        sh 'mkdir -p test_results'
        sh 'mkdir -p coverage_results'
    }
    echo 'Running EditMode tests...'
    dir("${env.PROJECT_DIR}") {
        script {
            String stageName = 'EditMode'
            String errorMassage = 'EditMode tests failed'
            unityUtil.runUnityStage(stageName, errorMassage)
        }
    }
}

def playModeTests() {
    echo 'Running PlayMode tests in Editor environment...'
    dir("${env.PROJECT_DIR}") {
        script {
            String stageName = 'PlayMode'
            String errorMassage = 'PlayMode tests failed'
            unityUtil.runUnityStage(stageName, errorMassage)
        }
    }
}

def codeCoverageReport() {
    dir("${env.PROJECT_DIR}") {
        echo 'Generating code coverage report...'
        script {
            String stageName = 'Coverage'
            String errorMassage = 'Code Coverage generation failed'
            unityUtil.runUnityStage(stageName, errorMassage)
        }

        echo 'Sending test report to Bitbucket.'
        script {
            //publish results to web server
            generalUtil.publishTestResultsHtmlToWebServer(
                FOLDER_NAME,
                TICKET_NUMBER,
                "${env.REPORT_DIR}/coverage_results/Report",
                'CodeCoverage'
            )
            unityUtil.sendTestReport(env.WORKSPACE, env.REPORT_DIR, COMMIT_HASH)
        }
    }
}

def buildProject() {
    script {
    echo 'Building Unity project...'
    //The following line assumed this folder exists in every project, adding check to ensure it does.
    sh "mkdir -p \"${env.PROJECT_DIR}/Assets/Editor/\""
    sh "cp Builder.cs \"${env.PROJECT_DIR}/Assets/Editor/\""

    String stageName = 'Webgl'
    String errorMassage = 'WebGL Build failed'
    unityUtil.runUnityStage(stageName, errorMassage)

    unityUtil.validateBuildLightingFiles()

    echo 'Sending Bitbucket WebGL build report'
    String pythonArgs = " ${COMMIT_HASH}" +
                        " ${env.REPORT_DIR}/build_project_results/*.log"

    // Pass '--debug' flag to create_bitbucket_coverage_report.py when a developer enable 'DEBUG_MODE'
    // groovylint-disable-next-line DuplicateStringLiteral
    if ((params.DEBUG_MODE ?: '').toUpperCase() == 'Y') {
        pythonArgs += ' --debug'
        echo "pythonArgs: ${pythonArgs}"
    }
    sh " python ${env.WORKSPACE}/python/create_bitbucket_webgl_build_report.py  ${pythonArgs}"

    echo 'Sending WebGL build and build log to dlx-webhost server'
    generalUtil.publishBuildResultsToWebServer(FOLDER_NAME, TICKET_NUMBER,
    "${env.PROJECT_DIR}/Builds", "${env.REPORT_DIR}/build_project_results")
}
}

pipeline {
    agent any

    tools {
        dotnetsdk 'dotnet-8'
    }

    parameters {
        string(name: 'PR_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_DESTINATION_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_REPO_HTML', defaultValue: '', description: '')
        string(name: 'PR_REPO_NAME', defaultValue: '', description: '')
        string(name: 'PR_COMMIT', defaultValue: '', description: '')
        string(name: 'PR_PROJECT', defaultValue: '', description: '')
        string(name: 'PR_STATE', defaultValue: '', description: '')
        string(
            name: 'TEST_RUN', defaultValue: '',
            description: 'This is a test run trigger. Fill in the parameter form with \'Y\' to run the pipeline without commit changes.'
        )
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                /* groovylint-disable DuplicateStringLiteral */
                [key: 'PR_BRANCH', value: '$.pullrequest.source.branch.name'],
                [key: 'PR_DESTINATION_BRANCH', value: '$.pullrequest.destination.branch.name'],
                [key: 'PR_REPO_HTML', value: '$.repository.links.self.href'],
                [key: 'PR_REPO_NAME', value: '$.repository.name'],
                [key: 'PR_COMMIT', value: '$.pullrequest.source.commit.hash'],
                [key: 'PR_PROJECT', value: '$.repository.full_name'],
                [key: 'PR_STATE', value: '$.pullrequest.state']
                /* groovylint-enable DuplicateStringLiteral */
            ],

            tokenCredentialId: 'trigger-token',
            regexpFilterText: '$PR_STATE',
            regexpFilterExpression: 'OPEN'
        )
    }

    environment {
        CI_PIPELINE = 'true'
        PROJECT_TYPE = 'Unity_Project'
        PROJECT_DIR = "${env.WORKSPACE}/${PROJECT_TYPE}"
        REPORT_DIR = "${env.WORKSPACE}/PRJob/${PR_BRANCH}"
        JOB_REPO = "${PR_REPO_HTML}"
        BITBUCKET_ACCESS_TOKEN = credentials('bitbucket-access-token')
        JENKINS_API_KEY = credentials('jenkins-api-key')
        REPO_SSH = "git@bitbucket.org:${PR_PROJECT}.git"
        DESTINATION_BRANCH = "${PR_DESTINATION_BRANCH}"
    }

    stages {
        timeout(time: 30, unit: 'MINUTES') {
            stage('Load Shared Library') {
                steps {
                    script {
                        sharedLibScript = load("${env.WORKSPACE}/sharedLibraries/src/service/general/sharedLibrary.groovy")
                        sharedLib = sharedLibScript.loadSharedLibrary()
                    }
                }
            }
        }
        // Prepare WORKSPACE: Environment Setup, env.WORKSPACE Preparation(Branch Management),
        // Unity Setup, Initial running the project on Unity Editor
        timeout(time: 10, unit: 'SECONDS') {
            stage('Prepare WORKSPACE') {
                steps {
                    script {
                        prepareWorkSpace()
                    }
                }
            }
        }
        timeout(time: 30, unit: 'MINUTES'){
            stage('Linting') {
                steps {
                    //Linting
                    script {
                        runLinting()
                    }
                }
            }
        }
        // Runs the project's EditMode tests, and then generates a test report and a code coverage report.
        // Sends the test results to Bitbucket once the tests complete.
        timeout(time: 30, unit: 'MINUTES') {
            stage('EditMode Tests') {
                steps {
                    script {
                        editModeTests()
                    }
                }
            }
        }
        // Runs the project's PlayMode tests, and then generates a code coverage report.
        // PlayMode tests need to be run once in the editor to generate the overall coverage report.
        timeout(time: 30, unit: 'MINUTES') {
            stage('PlayMode Tests in Editor') {
                steps {
                    script {
                        playModeTests()
                    }
                }
            }
        }
        // Merges the two coverage reports from the EditMode and PlayMode (editor) reports into one.
        // Then sends a coverage report to Bitbucket.
        timeout(time: 30, unit: 'MINUTES') {
            stage('Code Coverage\nSend Reports') {
                steps {
                    script {
                        codeCoverageReport()
                    }
                }
            }
        }
        //Builds the project and saves it.
        timeout(time: 30, unit: 'MINUTES') {
            stage('Build Project') {
                steps {
                    script {
                        buildProject()
                    }
                }
            }
        }

    // When the pipeline finishes, sends the build status to Bitbucket.
    post {
        always {
            script {
                echo 'Returning to the main branch...'
                generalUtil.checkoutBranch(PROJECT_DIR, DESTINATION_BRANCH)
                currentBuild.description = "${PR_BRANCH}"
            }
        }
        success {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'SUCCESSFUL', COMMIT_HASH)
            }
        }
        failure {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'FAILED', COMMIT_HASH)
            }
        }
        aborted {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'STOPPED', COMMIT_HASH)
            }
        }
    }
    }
