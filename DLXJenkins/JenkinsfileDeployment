def generalUtil
def unityUtil
def mainBranches = ['main', 'master']
def sharedLib // Use this variable to store the shared library, work as import statement
def resultStatus // Use this variable to store the package of result status, work as import statement

pipeline {
    agent any

    parameters {
        string(name: 'PR_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_DESTINATION_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_REPO_HTML', defaultValue: '', description: '')
        string(name: 'PR_REPO_NAME', defaultValue: '', description: '')
        string(name: 'PR_COMMIT', defaultValue: '', description: '')
        string(name: 'PR_PROJECT', defaultValue: '', description: '')
        string(name: 'PR_STATE', defaultValue: '', description: '')
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                /* groovylint-disable DuplicateStringLiteral */
                [key: 'PR_BRANCH', value: '$.pullrequest.source.branch.name'],
                [key: 'PR_DESTINATION_BRANCH', value: '$.pullrequest.destination.branch.name'],
                [key: 'PR_REPO_HTML', value: '$.repository.links.self.href'],
                [key: 'PR_REPO_NAME', value: '$.repository.name'],
                [key: 'PR_COMMIT', value: '$.pullrequest.source.commit.hash'],
                [key: 'PR_PROJECT', value: '$.repository.full_name'],
                [key: 'PR_STATE', value: '$.pullrequest.state']
                /* groovylint-enable DuplicateStringLiteral */
            ],

            tokenCredentialId: 'trigger-token',
            regexpFilterText: '$PR_STATE',
            regexpFilterExpression: 'MERGED'
        )
    }

    environment {
        CI_PIPELINE = false
        PROJECT_TYPE = 'Unity_Project'
        PROJECT_DIR = "${env.WORKSPACE}/${PROJECT_TYPE}"
        REPORT_DIR = "${env.WORKSPACE}/DeploymentJob/${PR_BRANCH}"
        JOB_REPO = "${PR_REPO_HTML}"
        BITBUCKET_ACCESS_TOKEN = credentials('bitbucket-access-token')
        DESTINATION_BRANCH = "${PR_DESTINATION_BRANCH}"
        DLX_PROJECT_LIST = env.DLX_LIST.split(',')
    }

    stages {
        stage('Load Shared Library') {
            steps {
                script {
                    try {
                        def LIBRARY_PATH = 'sharedLibraries'
                        echo "Loading local shared library from ${WORKSPACE}/${LIBRARY_PATH}"

                        // Create temporary Git repository
                        sh """
                            cd ${WORKSPACE}/${LIBRARY_PATH} && \
                            (rm -rf .git || true) && \
                            git init && \
                            git add --all && \
                            git commit -m 'init'
                        """

                        // Get the path of the temporary Git repository
                        def repoPath = sh(returnStdout: true, script: 'pwd').trim() + "/${LIBRARY_PATH}"

                        // Shared Library Registration
                        sharedLib = library identifier: 'local-lib@master',
                                retriever: modernSCM([$class: 'GitSCMSource', remote: "${repoPath}"]),
                                changelog: false
                        echo 'Successfully loaded shared library'
                    } catch (Exception e) {
                        echo "Failed to load shared library: ${e.message}"
                        error('Shared Library Loading Failed')
                    }
                }
            }
        }
        // Deletes the cloned branch from the build machine after it has been merged into main.
        // This prevents the build machine's storage from capping out.
        stage('Delete Merged Branch') {
            steps {
                script {
                    // Load the necessary packages
                    resultStatus = sharedLib.resource.ResultStatus

                    generalUtil = load("${env.WORKSPACE}/groovy/generalHelper.groovy")
                    unityUtil = load("${env.WORKSPACE}/groovy/unityHelper.groovy")

                    // Aborts the pipeline if it's not merging into the main.
                    if (!mainBranches.contains(DESTINATION_BRANCH)) {
                        env.FAILURE_REASON = 'Not merging to the main branch. Exiting the pipeline...'
                        currentBuild.result = buildResults.ABORTED
                        error(env.FAILURE_REASON)
                    }

                    // Getting the full commit hash from git in order to send the build status to Bitbucket.
                    COMMIT_HASH = generalUtil.getFullCommitHash(env.WORKSPACE, PR_COMMIT)

                    // Clean up Jenkins PR directory
                    generalUtil.cleanUpPRBranch(PR_BRANCH)

                    // Clean up dlx-webhost directory
                    env.FOLDER_NAME = "${JOB_NAME}".split('/').first()
                    def ticketNumber = generalUtil.parseTicketNumber(PR_BRANCH)
                    generalUtil.cleanMergedBranchFromWebServer(FOLDER_NAME, ticketNumber)
                }
            }
        }
        // Prepares the WORKSPACE for the build by cleaning the project, pulling main, and then telling Bitbucket that the
        // build is in progress. It also checks to see if the project's Unity version is downloaded, and installs it if not.
        stage('Prepare WORKSPACE') {
            environment {
                REPO_SSH = "git@bitbucket.org:${PR_PROJECT}.git"
            }
            steps {
                script {
                    if (!fileExists("${PROJECT_DIR}")) {
                        echo 'First time running pipeline. Cloning main branch...'
                        sh "git clone ${REPO_SSH} \"${PROJECT_DIR}\""
                    }
                }

                dir("${PROJECT_DIR}") {
                    // Ensure it stays in the main branch
                    echo 'Checkout to the main branch...'
                    sh "git checkout ${DESTINATION_BRANCH}"
                    echo 'Cleaning project...'
                    sh 'git reset --hard HEAD'
                    echo 'Pulling latest version of default branch...'
                    sh 'git pull'
                }

                script {
                    echo "Sending \'In Progress\' status to Bitbucket..."
                    generalUtil.sendBuildStatus(env.WORKSPACE, 'INPROGRESS', COMMIT_HASH, true)

                    echo 'Identifying Unity version...'
                    env.UNITY_EXECUTABLE = unityUtil.getUnityExecutable(env.WORKSPACE, PROJECT_DIR)
                }

                // Initial running the project on Unity Editor
                echo 'Running Unity in batch mode to setup initial files...'
                dir("${PROJECT_DIR}") {
                    script {
                        String stageName = 'Rider'
                        String errorMassage = 'Synchronizing Unity and Rider IDE solution files failed'
                        unityUtil.runUnityStage(stageName, errorMassage)
                    }
                }
            }
        }
        //linting stage to check formatting
        stage('Linting')
        {
            steps {
                //Linting
                dir("${REPORT_DIR}") {
                    sh 'mkdir -p linting_results'
                }
                echo 'running lint script'
                script {
                    sh "cp -f \'${env.WORKSPACE}/Bash/.editorconfig\' \'${PROJECT_DIR}\' 2>/dev/null"
                    echo "Parameters for bash: ${env.WORKSPACE}/Linting.bash ${PROJECT_DIR} ${REPORT_DIR}"
                    def exitCode = sh script: """sh \'${env.WORKSPACE}/Bash/Linting.bash\' \\
                        \'${PROJECT_DIR}\' \\
                        \'${REPORT_DIR}/linting_results\'""", returnStatus: true

                    echo "After bash call, exit code: ${exitCode}"
                    //handle exit code here no reports to be sent, since this for deployment and not PRs
                    if (exitCode != 0) {
                        //in this case we set build result to failure since we don't want to deploy bad code
                        catchError(buildResult: resultStatus.BUILD_STATUS.SUCCESS, stageResult: resultStatus.STAGE_STATUS.FAILURE) {
                            error("Linting failed with exit code: ${exitCode}") //we exit no matter what on error code != 0
                        }
                    }
                }
            }
        }
        // Runs the project's EditMode tests. Unlike the PR pipeline, if any tests fail, this will cause the pipeline to fail.
        // We do not want failing tests on main.
        stage('EditMode Tests') {
            steps {
                dir("${REPORT_DIR}") {
                    sh 'mkdir -p test_results'
                }
                echo 'Running EditMode tests...'
                dir("${PROJECT_DIR}") {
                    script {
                        String stageName = 'EditMode'
                        String errorMassage = 'EditMode tests failed'
                        unityUtil.runUnityStage(stageName, errorMassage)
                    }
                }
            }
        }
        // Runs the project's PlayMode tests. Unlike the PR pipeline, if any tests fail, this will cause the pipeline to fail.
        // We do not want failing tests on main. This stage is retried 5 times in case of Unity crashes (which are common).
        stage('PlayMode Tests In Editor') {
            steps {
                echo 'Running PlayMode tests...'
                dir("${PROJECT_DIR}") {
                    script {
                        String stageName = 'PlayMode'
                        String errorMassage = 'PlayMode tests failed'
                        unityUtil.runUnityStage(stageName, errorMassage)
                    }
                }
            }
        }
        // Builds the project for WebGL.
        stage('Build Project') {
            steps {
                echo 'Building Unity project for WebGL...'
                //The following line assumed this folder exists in every project, adding check to ensure it does.
                sh "mkdir -p \"${PROJECT_DIR}/Assets/Editor/\""
                sh "mv Builder.cs \"${PROJECT_DIR}/Assets/Editor/\""
                script {
                    String stageName = 'Webgl'
                    String errorMassage = 'WebGL Build failed'
                    unityUtil.runUnityStage(stageName, errorMassage)
                }
            }
        }
        // Deploys the build on our remote web server.
        stage('Deploy Build') {
            steps {
                echo 'Deploying build to LTI web server...'

                script {
                    sh "ssh -i ${env.SSH_KEY} ${env.DLX_WEB_HOST_URL} \"sudo mkdir -p /var/www/html/${FOLDER_NAME} \
                    && sudo chown vconadmin:vconadmin /var/www/html/${FOLDER_NAME}\""
                    sh "scp -i ${env.SSH_KEY} -rp ${PROJECT_DIR}/Builds/* \"${env.DLX_WEB_HOST_URL}:/var/www/html/${FOLDER_NAME}\""
                    //call script to copy that into the deployed server
                    sh "ssh -i ${env.SSH_KEY} ${env.DLX_WEB_HOST_URL} 'bash ~/ShellScripts/UpdateBuildURL.sh /var/www/html/${FOLDER_NAME}'"
                }

                script {
                    if (DLX_PROJECT_LIST.contains(PR_REPO_NAME)) {
                        echo 'Deploying build to eConestoga dlx web server...'
                        echo "List of DLX Repositories: ${DLX_PROJECT_LIST}"

                        // Create the directory and update the file permission
                        sh script: """
                            ssh -i ${env.SSH_KEY} ${env.DLX_ECONESTOGA_URL} \\
                            "sudo mkdir -p /var/www/html/${FOLDER_NAME} && sudo chown vconadmin:vconadmin /var/www/html/${FOLDER_NAME}"
                        """

                        // Secured copy all WebGL components to the econestoga dlx server
                        sh script: """
                            scp -i ${env.SSH_KEY} -rp ${PROJECT_DIR}/Builds/* \\
                            ${env.DLX_ECONESTOGA_URL}:/var/www/html/${FOLDER_NAME}
                        """

                        // Call script to update the WebGL "index.html"
                        sh script: """
                            ssh -i ${env.SSH_KEY} ${env.DLX_ECONESTOGA_URL} \\
                            'bash ~/ShellScripts/UpdateBuildURL.sh /var/www/html/${FOLDER_NAME}'
                        """
                    }
                }
            }
        }
    }

    // Sends the build status to Bitbucket. If the build was successful, Bitbucket will link to the deployed project on the web server.
    post {
        always {
            script {
                echo 'Returning to the main branch...'
                currentBuild.description = "${PR_BRANCH}"
                generalUtil.checkoutBranch(PROJECT_DIR, DESTINATION_BRANCH)
            }
        }
        success {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'SUCCESSFUL', COMMIT_HASH, true)
            }
        }
        failure {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'FAILED', COMMIT_HASH, true)
            }
        }
        aborted {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'STOPPED', COMMIT_HASH, true)
            }
        }
    }
}
