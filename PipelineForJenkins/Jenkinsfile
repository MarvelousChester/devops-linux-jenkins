def generalUtil

pipeline {
    agent any

    tools {
        // Use the configured Groovy tool and JDK 21
        groovy 'Groovy'
        jdk 'JDK 17'
        gradle 'Gradle'
    }

    parameters {
        string(name: 'PR_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_DESTINATION_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_REPO_HTML', defaultValue: '', description: '')
        string(name: 'PR_REPO_NAME', defaultValue: '', description: '')
        string(name: 'PR_COMMIT', defaultValue: '', description: '')
        string(name: 'PR_PROJECT', defaultValue: '', description: '')
        string(name: 'PR_STATE', defaultValue: '', description: '')
        string(name: 'TEST_RUN', defaultValue: '',
        description: 'This is a test run trigger. Fill in the parameter form with \'Y\' to run the pipeline without commit changes.')
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                /* groovylint-disable DuplicateStringLiteral */
                [key: 'PR_BRANCH', value: '$.pullrequest.source.branch.name'],
                [key: 'PR_DESTINATION_BRANCH', value: '$.pullrequest.destination.branch.name'],
                [key: 'PR_REPO_HTML', value: '$.repository.links.self.href'],
                [key: 'PR_REPO_NAME', value: '$.repository.name'],
                [key: 'PR_COMMIT', value: '$.pullrequest.source.commit.hash'],
                [key: 'PR_PROJECT', value: '$.repository.full_name'],
                [key: 'PR_STATE', value: '$.pullrequest.state']
                /* groovylint-enable DuplicateStringLiteral */
            ],
            tokenCredentialId: 'trigger-token',
            regexpFilterText: '$PR_STATE',
            regexpFilterExpression: 'OPEN|MERGED'
        )
    }

    environment {
        CI_PIPELINE = 'true'
        REPO_SSH = "git@bitbucket.org:${params.PR_PROJECT}.git"
        PROJECT_TYPE = 'Jenkins_Project'
        PROJECT_DIR = "${env.WORKSPACE}/${params.PR_REPO_NAME}"
        REPORT_DIR = "${env.WORKSPACE}/docs"
        BITBUCKET_ACCESS_TOKEN = credentials('bitbucket-access-token')
        /* groovylint-disable DuplicateStringLiteral */
        JAVA_HOME = tool 'JDK 17'
        GROOVY_HOME = tool 'Groovy'
        /* groovylint-enable DuplicateStringLiteral */
        PATH = "${JAVA_HOME}/bin:${GROOVY_HOME}/bin:${PATH}"
        JOB_REPO = "${PR_REPO_HTML}"
    }

    stages {
        stage('Prepare Workspace') {
            steps {
                script {
                    dir("${PROJECT_DIR}") {
                        echo 'Preparing the workspace...'
                        generalUtil = load("${env.WORKSPACE}/groovy/generalHelper.groovy")

                        if (generalUtil.isBranchUpToDateWithRemote(PR_BRANCH) && !TEST_RUN.equals('Y')) {
                            echo 'Local branch commit is up to date with remote branch, no changes. Aborting pipeline.'
                            currentBuild.result = 'ABORTED'
                            error('Branch is up to date, no changes.')
                        }

                        COMMIT_HASH = generalUtil.getFullCommitHash(env.WORKSPACE, PR_COMMIT)

                        // This sets environment variables for TICKET_NUMBER and FOLDER_NAME
                        generalUtil.initializeEnvironment(env.WORKSPACE, COMMIT_HASH, PR_BRANCH)

                        echo 'Cloning or updating repository...'
                        generalUtil.cloneOrUpdateRepo(PROJECT_TYPE, env.WORKSPACE, PROJECT_DIR, REPO_SSH, params.PR_BRANCH)

                        echo "Checking out branch ${params.PR_BRANCH}..."
                        dir(PROJECT_DIR) {
                            generalUtil.checkoutBranch(PROJECT_DIR, params.PR_BRANCH)
                        }
                    }
                }
            }
        }
        stage('Lint Groovy Code') {
            steps {
                script {
                    // Print docker info for troubleshooting
                    sh 'docker info'
                    echo 'Running groovy lint using Docker image nvuillam/npm-groovy-lint with disabled entrypoint'
                    def imageStr = 'nvuillam/npm-groovy-lint'
                    def entrypointStr = '--entrypoint=""'

                    // First lint: Groovy scripts
                    def exitCodeGroovy = docker.image(imageStr).inside(entrypointStr) {
                        return sh(
                            returnStatus: true,
                            script: """
                                echo "Linting Groovy scripts in ${PROJECT_DIR}/groovy ..."
                                npm-groovy-lint \\
                                    --failon error \\
                                    --output groovy-lint-report.json \\
                                    --config ${PROJECT_DIR}/.groovylintrc.groovy.json \\
                                    ${PROJECT_DIR}/groovy
                            """
                        )
                    }

                    echo "Groovy lint exit code: ${exitCodeGroovy}"

                    if (exitCodeGroovy != 0) {
                        echo "Linting errors in Groovy scripts. Calling Python script with 'Fail'."
                        sh script: """\
                            python '${env.WORKSPACE}/python/Lint_groovy_report.py' \
                            '${env.WORKSPACE}/groovy-lint-report.json' \
                            '${env.WORKSPACE}/jenkins-lint-report.json' \
                            ${COMMIT_HASH} \
                            Fail '${PROJECT_DIR}'
                        """.stripIndent()

                        // Mark the stage as failed but let the pipeline continue if desired
                        catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                            error("Groovy linting failed (exit code ${exitCodeGroovy})")
                        }
                    }

                    // Second lint: Jenkinsfiles
                    echo 'Running Jenkinsfile lint in Docker image nvuillam/npm-groovy-lint'

                    def exitCodeJenkins = docker.image(imageStr).inside(entrypointStr) {
                        return sh(
                            returnStatus: true,
                            script: """
                                echo "Linting Jenkinsfiles in DLXJenkins, JsJenkins, PipelineForJenkins ..."
                                npm-groovy-lint \\
                                    --failon error \\
                                    --output jenkins-lint-report.json \\
                                    --config ${PROJECT_DIR}/.groovylintrc.jenkins.json \\
                                    ${PROJECT_DIR}/DLXJenkins \\
                                    ${PROJECT_DIR}/JsJenkins \\
                                    ${PROJECT_DIR}/PipelineForJenkins
                            """
                        )
                    }

                    echo "Jenkinsfile lint exit code: ${exitCodeJenkins}"

                    if (exitCodeJenkins != 0 || exitCodeGroovy != 0) {
                        echo "Linting errors in Jenkinsfiles. Calling Python script with 'Fail'."
                        sh script: """\
                            python '${env.WORKSPACE}/python/Lint_groovy_report.py' \
                            '${env.WORKSPACE}/groovy-lint-report.json' \
                            '${env.WORKSPACE}/jenkins-lint-report.json' \
                            ${COMMIT_HASH} \
                            Fail '${PROJECT_DIR}'
                        """.stripIndent()
                        //groovylint-disable-next-line DuplicateMapLiteral, DuplicateStringLiteral
                        catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                            error("Jenkinsfile linting failed (exit code ${exitCodeJenkins})")
                        }
                    } else {
                        echo "No Jenkinsfile lint errors. Calling Python script with 'Pass'."
                        sh script: """\
                            python '${env.WORKSPACE}/python/Lint_groovy_report.py' \
                            '${env.WORKSPACE}/groovy-lint-report.json' \
                            '${env.WORKSPACE}/jenkins-lint-report.json' \
                            ${COMMIT_HASH} \
                            Pass '${PROJECT_DIR}'
                        """.stripIndent()
                    }
                }
            }
        }
        stage('Generate Groovydoc') {
            steps {
                script {
                    echo 'Generating Groovydoc...'
                    dir(PROJECT_DIR) {
                        // Capture the list of .groovy files into a variable
                        def fileList = sh(
                            script: "find ${PROJECT_DIR}/groovy -type f -name '*.groovy'",
                            returnStdout: true).trim()

                        if (!fileList) {
                            error "No .groovy files found in ${PROJECT_DIR}/groovy"
                        }

                        // Debug: Print the file list
                        echo "Files found for Groovydoc: ${fileList}"

                        // Use the fileList with proper quoting
                        sh """
                        mkdir -p ${REPORT_DIR}
                        groovydoc -verbose -d ${REPORT_DIR} ${fileList.replaceAll('\\s+', ' ')}
                        """

                        echo "Documentation generated at ${REPORT_DIR}"

                        if (params.PR_STATE == 'MERGED') {
                            generalUtil.publishGroovyDocToWebServer(REPORT_DIR)
                        }
                    }
                }
            }
        }
        stage('Run Unit Tests') {
            steps {
                script {
                    sh 'gradle test'
                }
            }
        }
        stage('Publish Test Results') {
            steps {
                script {
                    junit 'build/test-results/test/*.xml'
                }
            }
        }
    }

    post {
        always {
            script {
                echo 'Cleaning up the workspace...'
            // deleteDir() this is commented out for now, but in future we can do clean up if needed
            }
        }
        success {
            script {
                echo 'Groovydoc generation completed successfully.'
                generalUtil.sendBuildStatus(env.WORKSPACE, 'SUCCESSFUL', COMMIT_HASH)
            }
        }
        failure {
            script {
                echo 'Groovydoc generation failed.'
                generalUtil.sendBuildStatus(env.WORKSPACE, 'FAILED', COMMIT_HASH)
            }
        }
        aborted {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'STOPPED', COMMIT_HASH)
            }
        }
    }
}
