def generalUtil
def sharedLib // Use this variable to store the shared library, work as import statement
def resultStatus // Use this variable to store the package of result status, work as import statement

pipeline {
    agent any

    options {
        timeout(time: 1, unit: 'HOURS')
    }

    tools {
        // Use the configured Groovy tool and JDK 21
        groovy 'Groovy'
        jdk 'JDK 17'
        gradle 'Gradle'
    }

    parameters {
        string(name: 'PR_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_DESTINATION_BRANCH', defaultValue: '', description: '')
        string(name: 'PR_REPO_HTML', defaultValue: '', description: '')
        string(name: 'PR_REPO_NAME', defaultValue: '', description: '')
        string(name: 'PR_COMMIT', defaultValue: '', description: '')
        string(name: 'PR_PROJECT', defaultValue: '', description: '')
        string(name: 'PR_STATE', defaultValue: '', description: '')
        string(name: 'TEST_RUN', defaultValue: '',
        description: 'This is a test run trigger. Fill in the parameter form with \'Y\' to run the pipeline without commit changes.')
    }

    triggers {
        GenericTrigger(
            genericVariables: [
                /* groovylint-disable DuplicateStringLiteral */
                [key: 'PR_BRANCH', value: '$.pullrequest.source.branch.name'],
                [key: 'PR_DESTINATION_BRANCH', value: '$.pullrequest.destination.branch.name'],
                [key: 'PR_REPO_HTML', value: '$.repository.links.self.href'],
                [key: 'PR_REPO_NAME', value: '$.repository.name'],
                [key: 'PR_COMMIT', value: '$.pullrequest.source.commit.hash'],
                [key: 'PR_PROJECT', value: '$.repository.full_name'],
                [key: 'PR_STATE', value: '$.pullrequest.state']
                /* groovylint-enable DuplicateStringLiteral */
            ],
            tokenCredentialId: 'trigger-token',
            regexpFilterText: '$PR_STATE',
            regexpFilterExpression: 'OPEN|MERGED'
        )
    }

    environment {
        CI_PIPELINE = 'true'
        REPO_SSH = "git@bitbucket.org:${params.PR_PROJECT}.git"
        PROJECT_TYPE = 'Jenkins_Project'
        PROJECT_DIR = "${env.WORKSPACE}/${params.PR_REPO_NAME}"
        REPORT_DIR = "${env.WORKSPACE}/docs"
        BITBUCKET_ACCESS_TOKEN = credentials('bitbucket-access-token')
        /* groovylint-disable DuplicateStringLiteral */
        JAVA_HOME = tool 'JDK 17'
        GROOVY_HOME = tool 'Groovy'
        /* groovylint-enable DuplicateStringLiteral */
        PATH = "${JAVA_HOME}/bin:${GROOVY_HOME}/bin:${PATH}"
        JOB_REPO = "${PR_REPO_HTML}"

        // Environmental variables for static analysis
        SONARQUBE_SERVER = 'SonarServer'
        SONARQUBE_SCANNER = 'sonarqube-scanner'
        SONAR_PROJECT_KEY = "${env.JOB_NAME.split('/')[0]}-PR"
    }

    stages {
        stage('Load Shared Library') {
            steps {
                script {
                    try {
                        def LIBRARY_PATH = 'sharedLibraries'
                        echo "Loading local shared library from ${WORKSPACE}/${LIBRARY_PATH}"

                        // Create temporary Git repository
                        sh """
                            cd ${WORKSPACE}/${LIBRARY_PATH} && \
                            (rm -rf .git || true) && \
                            git init && \
                            git add --all && \
                            git commit -m 'init'
                        """

                        // Get the path of the temporary Git repository
                        def repoPath = sh(returnStdout: true, script: 'pwd').trim() + "/${LIBRARY_PATH}"

                        // Shared Library Registration
                        sharedLib = library identifier: 'local-lib@master',
                                retriever: modernSCM([$class: 'GitSCMSource', remote: "${repoPath}"]),
                                changelog: false
                        echo 'Successfully loaded shared library'
                    } catch (Exception e) {
                        echo "Failed to load shared library: ${e.message}"
                        error('Shared Library Loading Failed')
                    }
                }
            }
        }
        stage('Prepare Workspace') {
            steps {
                script {
                    dir("${PROJECT_DIR}") {
                        try {
                            // Load the necessary packages
                            resultStatus = sharedLib.resource.ResultStatus

                            echo 'Preparing the workspace...'
                            generalUtil = load("${env.WORKSPACE}/groovy/generalHelper.groovy")

                            if (generalUtil.isBranchUpToDateWithRemote(PR_BRANCH) && !TEST_RUN.equals('Y')) {
                                echo 'Local branch commit is up to date with remote branch, no changes. Aborting pipeline.'
                                currentBuild.result = resultStatus.BUILD_STATUS.ABORTED
                                error('Branch is up to date, no changes.')
                            }

                            COMMIT_HASH = generalUtil.getFullCommitHash(env.WORKSPACE, PR_COMMIT)

                            // This sets environment variables for TICKET_NUMBER and FOLDER_NAME
                            generalUtil.initializeEnvironment(env.WORKSPACE, COMMIT_HASH, PR_BRANCH)

                            echo 'Cloning or updating repository...'
                            generalUtil.cloneOrUpdateRepo(PROJECT_TYPE, env.WORKSPACE, PROJECT_DIR, REPO_SSH, params.PR_BRANCH)

                            echo "Checking out branch ${params.PR_BRANCH}..."
                            dir(PROJECT_DIR) {
                                generalUtil.checkoutBranch(PROJECT_DIR, params.PR_BRANCH)
                            }
                        } catch (Exception e) {
                            echo "Error in Prepare Workspace stage: ${e.getMessage()}"
                            currentBuild.result = resultStatus.BUILD_STATUS.FAILURE
                            error("Workspace preparation failed: ${e.getMessage()}")
                        }
                    }
                }
            }
        }
        stage('Lint Groovy Code') {
            steps {
                script {
                    // Print docker info for troubleshooting
                    sh 'docker info'
                    echo 'Running groovy lint using Docker image nvuillam/npm-groovy-lint with disabled entrypoint'
                    def imageStr = 'nvuillam/npm-groovy-lint'
                    def entrypointStr = '--entrypoint=""'

                    // First lint: Groovy scripts
                    def exitCodeGroovy = docker.image(imageStr).inside(entrypointStr) {
                        return sh(
                            returnStatus: true,
                            script: """
                                echo "Linting Groovy scripts in ${PROJECT_DIR}/groovy ..."
                                npm-groovy-lint \\
                                    --failon error \\
                                    --no-parse \\
                                    --output groovy-lint-report.json \\
                                    --config ${PROJECT_DIR}/.groovylintrc.groovy.json \\
                                    ${PROJECT_DIR}/groovy
                            """
                        )
                    }

                    echo "Groovy lint exit code: ${exitCodeGroovy}"

                    if (exitCodeGroovy != 0) {
                        echo "Linting errors in Groovy scripts. Calling Python script with 'Fail'."
                        sh script: """\
                            python '${env.WORKSPACE}/python/Lint_groovy_report.py' \
                            '${env.WORKSPACE}/groovy-lint-report.json' \
                            '${env.WORKSPACE}/jenkins-lint-report.json' \
                            ${COMMIT_HASH} \
                            Fail '${PROJECT_DIR}'
                        """.stripIndent()

                        // Mark the stage as failed but let the pipeline continue if desired
                        catchError(buildResult: resultStatus.BUILD_STATUS.SUCCESS, stageResult: resultStatus.STAGE_STATUS.FAILURE) {
                            error("Groovy linting failed (exit code ${exitCodeGroovy})")
                        }
                    }

                    // Second lint: Jenkinsfiles
                    echo 'Running Jenkinsfile lint in Docker image nvuillam/npm-groovy-lint'

                    def exitCodeJenkins = docker.image(imageStr).inside(entrypointStr) {
                        return sh(
                            returnStatus: true,
                            script: """
                                echo "Linting Jenkinsfiles in DLXJenkins, JsJenkins, PipelineForJenkins ..."
                                npm-groovy-lint \\
                                    --failon error \\
                                    --no-parse \\
                                    --output jenkins-lint-report.json \\
                                    --config ${PROJECT_DIR}/.groovylintrc.jenkins.json \\
                                    ${PROJECT_DIR}/DLXJenkins \\
                                    ${PROJECT_DIR}/JsJenkins \\
                                    ${PROJECT_DIR}/PipelineForJenkins
                            """
                        )
                    }

                    echo "Jenkinsfile lint exit code: ${exitCodeJenkins}"

                    if (exitCodeJenkins != 0 || exitCodeGroovy != 0) {
                        echo "Linting errors in Jenkinsfiles. Calling Python script with 'Fail'."
                        sh script: """\
                            python '${env.WORKSPACE}/python/Lint_groovy_report.py' \
                            '${env.WORKSPACE}/groovy-lint-report.json' \
                            '${env.WORKSPACE}/jenkins-lint-report.json' \
                            ${COMMIT_HASH} \
                            Fail '${PROJECT_DIR}'
                        """.stripIndent()

                        catchError(buildResult: resultStatus.BUILD_STATUS.SUCCESS, stageResult: resultStatus.STAGE_STATUS.FAILURE) {
                            error("Jenkinsfile linting failed (exit code ${exitCodeJenkins})")
                        }
                    } else {
                        echo "No Jenkinsfile lint errors. Calling Python script with 'Pass'."
                        sh script: """\
                            python '${env.WORKSPACE}/python/Lint_groovy_report.py' \
                            '${env.WORKSPACE}/groovy-lint-report.json' \
                            '${env.WORKSPACE}/jenkins-lint-report.json' \
                            ${COMMIT_HASH} \
                            Pass '${PROJECT_DIR}'
                        """.stripIndent()
                    }
                }
            }
        }
        stage('Generate Groovydoc') {
            steps {
                script {
                    echo 'Generating Groovydoc...'
                    dir(PROJECT_DIR) {
                        // Capture the list of .groovy files into a variable
                        def fileList = sh(
                            script: "find ${PROJECT_DIR}/groovy -type f -name '*.groovy'",
                            returnStdout: true).trim()

                        if (!fileList) {
                            error "No .groovy files found in ${PROJECT_DIR}/groovy"
                        }

                        // Debug: Print the file list
                        echo "Files found for Groovydoc: ${fileList}"

                        // Use the fileList with proper quoting
                        sh """
                        mkdir -p ${REPORT_DIR}
                        groovydoc -verbose -d ${REPORT_DIR} ${fileList.replaceAll('\\s+', ' ')}
                        """

                        echo "Documentation generated at ${REPORT_DIR}"

                        if (params.PR_STATE == 'MERGED') {
                            generalUtil.publishGroovyDocToWebServer(REPORT_DIR)
                        }
                    }
                }
            }
        }

        stage('Run Unit Tests') {
            steps {
                script {
                    sh """
                    gradle test -PsharedLibraryDir=${env.WORKSPACE}/sharedLibraries
                    """
                }
            }
        }
        stage('Publish Test Results') {
            steps {
                script {
                    junit 'build/test-results/test/*.xml'
                }
            }
        }
        // Runs static code analysis using SonarQube installed in Jenkins virtual machine.
        stage('Static Analysis') {
            steps {
                dir("${PROJECT_DIR}") {
                    pwd()
                    script {
                        catchError(buildResult: resultStatus.BUILD_STATUS.SUCCESS, stageResult: resultStatus.STAGE_STATUS.FAILURE) {
                            String scannerHome = tool SONARQUBE_SCANNER
                            echo "SonarQube scanner located at: ${scannerHome}"

                            withSonarQubeEnv(SONARQUBE_SERVER) {
                                String sonarCommand = "\"${scannerHome}/bin/sonar-scanner\" " +
                            "\"-Dsonar.projectKey=${env.SONAR_PROJECT_KEY}\" " +
                            '\"-Dsonar.host.url=http://localhost:9000/sonarqube\" ' +
                            '\"-Dsonar.sources=.\" ' +
                            '\"-Dsonar.log.level=DEBUG\" ' +
                            '\"-Dsonar.verbose=true\" ' +
                            '\"-Dsonar.lang.patterns.grvy="**/*.groovy,**/Jenkinsfile,**/JenkinsfileDeployment"\" ' +
                            '\"-Dsonar.exclusions=**/python/log-template/logs.html,**/Builder.cs,**/build.gradle,**/Bash/**\" ' +
                            '\"-Dsonar.python.version=3.10\"'

                                echo "Executing SonarQube scanner with command: ${sonarCommand}"
                                sh sonarCommand
                            }
                        }
                    }
                }

                withCredentials([string(credentialsId: 'SonarQube', variable: 'SONAR_QUBE_AUTH_TOKEN')]) {
                    script {
                        catchError(buildResult: resultStatus.BUILD_STATUS.SUCCESS, stageResult: resultStatus.STAGE_STATUS.FAILURE) {
                            Map status = generalUtil.checkQualityGateStatus(SONAR_PROJECT_KEY, env.SONAR_QUBE_AUTH_TOKEN)

                            final String STATUS_OK = 'OK'

                            if ((status.entireCodeStatus != STATUS_OK) || (status.newCodeStatus != STATUS_OK)) {
                                echo "Entire Code Status: ${status.entireCodeStatus}, New Code Status: ${status.newCodeStatus}"
                                error('Quality gate failed!')
                            } else {
                                echo 'Quality gate passed!'
                            }
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                echo 'Cleaning up the workspace...'
                currentBuild.description = "${PR_BRANCH}"
                // deleteDir() this is commented out for now, but in future we can do clean up if needed
            }
        }
        success {
            script {
                echo 'Groovydoc generation completed successfully.'
                generalUtil.sendBuildStatus(env.WORKSPACE, 'SUCCESSFUL', COMMIT_HASH)
            }
        }
        failure {
            script {
                echo 'Groovydoc generation failed.'
                generalUtil.sendBuildStatus(env.WORKSPACE, 'FAILED', COMMIT_HASH)
            }
        }
        aborted {
            script {
                generalUtil.sendBuildStatus(env.WORKSPACE, 'STOPPED', COMMIT_HASH)
            }
        }
    }
}
