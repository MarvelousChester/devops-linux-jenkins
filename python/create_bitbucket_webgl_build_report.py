import os
import argparse
import json
import requests
import copy
from datetime import datetime, timezone

# Import extract_log_message.py
from extract_build_error_log_messages import ERROR_TEMPLATE, extract_error_log, cmd_debug_display, error_message_object_debug_display

"""
Command Line Arguments
 - Required Arguments  
    >> commit         : The target commit hash to submit the report
    >> build_log_path : Path to the Unity build result log file (e.g. build_project.log)

 - Optional Argument 
    >> --debug        : Enable debug display
"""
# Required Arguments  
parser = argparse.ArgumentParser(description="Create and submit Bitbucket PR report form.")
parser.add_argument("commit_hash", help="The commit hash the report will be sent to.")
parser.add_argument("build_log_path", help="Path to build_project.log file") 

# Optional Argument 
parser.add_argument("--debug", action="store_true", help="Enable debug mode")


# Environment variables:
# Create getter function for error handling
def get_env_variable(var_name): 
    value = os.getenv(var_name)
    if value is None:
        raise EnvironmentError(f"Required environment variable '{var_name}' is missing.")
    return value

access_token  = get_env_variable('BITBUCKET_ACCESS_TOKEN') # Access token generated by ci-cathering account
ticket_number = get_env_variable('TICKET_NUMBER')          # PR ticket number
pr_repo       = get_env_variable('JOB_REPO')               # Project repository name
folder_name   = get_env_variable('FOLDER_NAME')            # The report folder name at the web-dlx server

exclude_keywords = ["ALSA", "Licensing", "FallbackError"]  # This is keywords will be passed to extract_build_error_log_messages.py 
                                                           # as a cmd argument with --exclude flag
                                                           # The error messages will be excluded if the message inculdes one of these keywords

# Create HTTP header
headers = {
    "Accept": "application/json",
    "Content-Type": "application/json",
    "Authorization": "Bearer " + access_token
}




"""
Function Name: create_report
Description  : Creates a Bitbucket code coverage report and submits it.

Args:
    commit_hash (str)       : The commit hash for which the report is generated.
    build_log_path (str)    : Path to the build log file.
    debug (bool)            : Enable or disable debug display.

Returns:
    dict: A dictionary containing the response status and message from Bitbucket.
          - On success: {"status": "success", "response": response.json()}
          - On failure: {"status": "failed", "error": error_message"}
"""
def create_report(commit_hash, build_log_path, debug=False):
    # Build the Bitbucket report url
    # Path parameters should be followed the format below
    # https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}'
    # example of pr_repo: https://api.bitbucket.org/2.0/repositories/VARLab/varlab-asset-store
    report_url = f'{pr_repo}/commit/{commit_hash}/reports/build-report'
    
    # Delete annotations if report already has annotations
    index = 1
    while True:
        annotation_url = f"{report_url}/annotations/{ticket_number}-{index}"

        # Create Bitbucekt annotation GET request 
        get_response = get_annotation(annotation_url)
        if debug:
            print(annotation_url)
            print(get_response)

        if get_response["status"] == "not_found":  
            break
        elif get_response["status"] == "failed": 
            print(f"\nError at index {index}: {get_response['error']}")
            break
        
        if debug:
            print(f"\nAnnotation {index} is found.")
        
        # Create Bitbucekt annotation Delete request 
        delete_response = delete_annotation(annotation_url)
        
        if debug:
            print(f"\nDELETE Response: {delete_response}")

        if delete_response["status"] == "success":
            if debug:
                print(f"\nAnnotation {index} deleted successfully.")
        else:
            print(f"\nFailed to delete annotation {index}: {delete_response.get('error', 'Unknown error')}")
            break  # Stop on failure to avoid potential infinite loop

        index += 1
    

    # Extract build status from the build log
    build_result = extract_error_log(build_log_path, exclude_keywords, debug)        

    details = "WebGL Build Result: No build result available."
    # Set base details message
    details = f"WebGL Build Result: {build_result['build_result']}"

    # Append Error Code only if it exists
    if build_result.get("exit_code"):  
        details += f" || Error Code: {build_result['exit_code']}"

    # Create the Bitbucket coverage report form    
    report = { 
        "title": f"{ticket_number}: WebGL Build Report",
        "details": details, 
        "report_type": "TEST",
        "reporter": "Jenkins",
        "result": "PASSED" if build_result["build_result"] == "Success" else "FAILED",
        "link": f"https://webdlx.vconestoga.com/{folder_name}/PR-Builds/{ticket_number}/index.html" if build_result["build_result"] == "Success"
        else f"https://webdlx.vconestoga.com/{folder_name}/PR-Builds/{ticket_number}/Build-Log/build_project.log",
    }
    

    if isinstance(build_result.get("system_error_messages"), list):
        # Ensure `report["data"]` exists before appending
        if "data" not in report:
            report["data"] = []

        # Max 'data' number is 10 in total 
        for idx, error in enumerate(build_result["system_error_messages"][:10], start=1):
            report["data"].append({
                "type": "TEXT",
                "title": f"Error {idx}:",
                "value": error
            })

    # Transfer the data type string object to json object
    report_json = json.dumps(report, indent=4)

    if debug:
        # Print the report format 
        print("\n\nBitbucket Report API Form:")
        print(f"url: {report_url}")
        print(f"headers: {headers}")
        print(report_json)


    try:
        # Create HTTP PUT request
        response = requests.put(report_url, data=report_json, headers=headers)
        # Raise an HTTPError exception if the status code is 4xx or 5xx
        response.raise_for_status()  

        return {"status": "success", "response": response.json()} 
    except requests.exceptions.RequestException as e:
        error_message = {}
        
        # Check the request body information if the request object exists.
        if e.request:
            error_message["request_body"] = e.request.body
        
        # Process error messages if there is a response object
        if e.response:
            try:
                error_message["error_response"] = e.response.json()
            except ValueError:
                error_message["error_response"] = e.response.text   # If JSON parsing fails, treat as plain text
        else:
            error_message["error_response"] = "No response received."

        return {"status": "failed", "error": error_message}


"""
    Function Name: get_annotation()
    Description  : Create HTTP:GET request to get an annotation from Bitbucket cloud report

    Args:
        annotation_url (str): The target annotation url

    Returns:
        dict: Response status and message from Bitbucket (success or failed).
"""
def get_annotation(annotation_url):
    try:
        response = requests.get(annotation_url, headers=headers)
        response.raise_for_status() 
        return {"status": "success", "response": response.json()} 
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 404:
            return {"status": "not_found"} 
        return {"status": "failed", "error": e.response.text if e.response else "No response received."}
    except requests.exceptions.RequestException as e:
        return {"status": "failed", "error": str(e)}


"""
    Function Name: delete_annotation()
    Description  : Create HTTP:DELETE request to delete an annotation from Bitbucket cloud report

    Args:
        annotation_url (str): The target annotation url

    Returns:
        dict: Response status and message from Bitbucket (success or failed).
"""
def delete_annotation(annotation_url):
    try:
        response = requests.delete(annotation_url, headers=headers)
        response.raise_for_status()

        # Bitbucket may return empty body on success, so use response.text as fallback
        return {"status": "success", "response": response.text or "Deleted successfully"}  
    except requests.exceptions.HTTPError as e:
        if e.response and e.response.status_code == 404:
            return {"status": "not_found"}  # Not found case
        return {"status": "failed", "error": e.response.text if e.response else "No response received."}
    except requests.exceptions.RequestException as e:
        return {"status": "failed", "error": str(e)}



"""
    Function Name: put_annotation
    Description  : Put the annotations of test error messages on the Bitbucket PR report

    Args:
        commit_hash (str)   : The target commit hash to submit the report.
        build_log_path (str): Path to the build log file.
        debug (bool)        : Enable or disable debug display.

    Returns:
        dict: Response status and message from Bitbucket (success or failed).
"""
def put_annotation(commit_hash, build_log_path, debug=False):    
    build_result = extract_error_log(build_log_path, exclude_keywords, debug)
    annotation_results = []

    # Ensure there are errors in "unity_error"
    for index, error in enumerate(build_result["unity_error"]["errors"], start=1):
        # Build the Bitbucket annotation URL
        annotation_url = f'{pr_repo}/commit/{commit_hash}/reports/build-report/annotations/{ticket_number}-{index}'

        # Convert line number to integer if possible
        line_number = int(error["line_number"]) if error["line_number"].isdigit() else None

        # Build the Bitbucket annotation API form
        annotation = json.dumps({
            "external_id": f"{ticket_number}-{index}",
            "annotation_type": "BUG",
            "path": error["file_path"],             # Corrected path access
            "line": line_number,                    # Convert to int if possible
            "summary": error["error_code"],         # Corrected error code access
            "details": error["error_description"],  # Corrected error description access
            "result": "FAILED",
            "severity": "HIGH",
            "created_on": datetime.now(timezone.utc).isoformat()
        })

        if debug:
            # Print the report format 
            print(f"\n\nNo.{index} Bitbucket Annotation API Form:")
            print(f"url: {annotation_url}")
            print(f"headers: {headers}")
            print(annotation)

        try:
            response = requests.put(annotation_url, data=annotation, headers=headers)
            response.raise_for_status()  # Raise an HTTPError exception if the status code is 4xx or 5xx
            annotation_results.append({"status": "success", "response": response.json()}) # Accumulate the success repsonding messages from Bitbucket for debugging

        except requests.exceptions.RequestException as e:
            error_message = {}

            # Check the request body information if the request object exists.
            if e.request:
                error_message["request_body"] = e.request.body

            # Process error messages if there is a response object
            if e.response:
                try:
                    error_message["error_response"] = e.response.json()
                except ValueError:
                    error_message["error_response"] = e.response.text  # If JSON parsing fails, treat as plain text
            else:
                error_message["error_response"] = "No response received."
            
            # Accumulate the failed repsonding messages from Bitbucket for debugging
            annotation_results.append({"status": "failed", "error": error_message})
        
    return annotation_results




def main(commit_hash, build_log_path, debug=False):
    if debug:
        # Print Command Line Arguments
        print(f"---WebGL Build Report DEBUG INFO-----------------------------------------------------------------------------------------------------------")
        print(f"   - Commit: {commit_hash}")
        print(f"   - Build Log File Path: {build_log_path}")


    # Calls create_report and prints the result
    report_api_result = create_report(commit_hash, build_log_path, debug)
    if debug:
        print("\n\nReport API Request Response:")
        if report_api_result.get("status") == "success":
            print("Status: SUCCESS")
            print(json.dumps(report_api_result.get("response", {}), indent=4))
        else:
            print("Status: FAILED")
            error_info = report_api_result.get("error", {})
            status_code = error_info.get("status_code", "N/A") 
            print(f"Error Code: {status_code}")
            print(json.dumps(error_info, indent=4))


    # Put annotations at the Bitbucket report
    annotation_api_results = put_annotation(commit_hash, build_log_path, debug)
    if debug:
        print("\n\nBitbucket Annotation API Request Response:")
        if annotation_api_results:
            for annotation_api_result in annotation_api_results:
                if annotation_api_result.get("status") == "failed":
                    print("Status: FAILED")
                    print(json.dumps(annotation_api_result.get("error", {}), indent=4))
                elif annotation_api_result.get("status") == "success":
                    print("Status: SUCCESS")
                    print(json.dumps(annotation_api_result.get("response", {}), indent=4))
        else:
            print("No annotations were processed.")


if __name__ == "__main__":
    # Parse command-line arguments
    args = parser.parse_args()

    main(args.commit_hash, args.build_log_path, args.debug)