import os
import argparse
import json
import requests
from datetime import datetime, timezone


# Import extract_coverage_rates.py and extract_test_result.py
from JsReporting.extract_coverage_rates import extract_coverage_rates
from JsReporting.extract_test_result import extract_test_summary
from JsReporting.extract_test_result import extract_failure_details


"""
Command Line Arguments
 - Required Arguments  
    >> commit             : The target commit hash to submit the report
    >> coverage_file_path : Path to the JSON coverage result file (e.g. coverage-summary.json)
    >> test_file_path     : Path to the JSON test result file (e.g. test-results.json)

 - Mutually Exclusive Flags (only one can be selected)
    >> --server       : Indicates the result comes from the server-side project
    >> --client       : Indicates the result comes from the client-side project

 - Optional Argument 
    >> --debug        : Enable debug display
"""
# Required Arguments  
parser = argparse.ArgumentParser(description="Create and submit Bitbucket PR report form.")
parser.add_argument("commit", help="The commit hash the report will be sent to.")
parser.add_argument("coverage_file_path", help="Path to coverage-summary.json.")  
parser.add_argument("test_file_path", help="Path to test-results.json.") 

# Mutually Exclusive Flags
group = parser.add_mutually_exclusive_group(required=True)  # Only one option can be selected
group.add_argument('--server', action='store_true', help='Indicates the result is from a server-side project')
group.add_argument('--client', action='store_true', help='Indicates the result is from a client-side project')

# Optional Argument 
parser.add_argument("--debug", action="store_true", help="Enable debug mode")


# Environment variables:
# Create getter function for error handling
def get_env_variable(var_name): 
    value = os.getenv(var_name)
    if value is None:
        raise EnvironmentError(f"Required environment variable '{var_name}' is missing.")
    return value

access_token  = get_env_variable('BITBUCKET_ACCESS_TOKEN') # Access token generated by ci-cathering account
ticket_number = get_env_variable('TICKET_NUMBER')          # PR ticket number
pr_repo       = get_env_variable('JOB_REPO')               # Project repository name
folder_name   = get_env_variable('FOLDER_NAME')            # The report folder name at the web-dlx server


# Create HTTP header
headers = {
    "Accept": "application/json",
    "Content-Type": "application/json",
    "Authorization": "Bearer " + access_token
}


"""
    Function Name: create_report
    Description  : Creates a Bitbucket code coverage report and submits it.

    Args:
        url (str)               : Bitbucket URL to submit the report.
        coverage_file_path (str): Path to coverage-summary.json.
        test_file_path (str)    : Path to test-results.json.
        project_type (str)      : Indicates whether the project is server-side or client-side.
        debug (bool)            : Enable or disable debug display.

    Returns:
        dict: Response status and message from Bitbucket (success or failed).
"""
def create_report(commit_hash, coverage_file_path, test_file_path, project_type, debug=False):
    # Build the Bitbucket report url
    # Path parameters should be followed the format below
    # https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}'
    # example of pr_repo: https://api.bitbucket.org/2.0/repositories/VARLab/varlab-asset-store
    report_url = f'{pr_repo}/commit/{commit_hash}/reports/{project_type}-coverage-report'

    # Get coverage result
    # Code coverage summary will be returned as a dictionary
    coverage_result = extract_coverage_rates(coverage_file_path, debug)

    # Get test result
    # The test result will be returned as a dictionary
    test_result = extract_test_summary(test_file_path, debug, filter_status="failed")

    # Check whether all tests are passed or not
    is_tests_passed = test_result["summary"]["total_tests"] == test_result["summary"]["passed_tests"]

    # Create the Bitbucket coverage report form    
    report = json.dumps({ 
        "title": f"{ticket_number}: {project_type.capitalize()} Test and Coverage Report",
        "details": f"Test-Results: {test_result['summary']['passed_tests']}/{test_result['summary']['total_tests']}",
        "report_type": "COVERAGE",
        "reporter": "Jenkins",
        "result": "PASSED" if is_tests_passed else "FAILED",
        "link": f"https://webdlx.vconestoga.com/{folder_name}/Reports/{ticket_number}/{project_type}-report/index.html",
        "data": [
            {
                "type": "PERCENTAGE",
                "title": "Statements Coverage",
                "value": coverage_result['statements']
            },
            {
                "type": "PERCENTAGE",
                "title": "Branches Coverage",
                "value": coverage_result['branches']
            },
            {
                "type": "PERCENTAGE",
                "title": "Functions Coverage",
                "value": coverage_result['functions']
            },
            {
                "type": "PERCENTAGE",
                "title": "Lines Coverage",
                "value": coverage_result['lines']
            }
        ]
    })
 
    if debug:
        # Print the report format 
        print("\n\nBitbucket Report API Form:")
        print(f"url: {report_url}")
        print(f"headers: {headers}")
        print(report)

    try:
        # Create HTTP PUT request
        response = requests.put(report_url, data=report, headers=headers)
        # Raise an HTTPError exception if the status code is 4xx or 5xx
        response.raise_for_status()  
        return {"status": "success", "response": response.json()} 
    except requests.exceptions.RequestException as e:
        error_message = {}
        
        # Check the request body information if the request object exists.
        if e.request:
            error_message["request_body"] = e.request.body
        
        # Process error messages if there is a response object
        if e.response:
            try:
                error_message["error_response"] = e.response.json()
            except ValueError:
                error_message["error_response"] = e.response.text   # If JSON parsing fails, treat as plain text
        else:
            error_message["error_response"] = "No response received."

        return {"status": "failed", "error": error_message}


"""
    Function Name: put_annotation
    Description  : Put the annotations of test error messages on the Bitbucket PR report

    Args:
        commit_hash (str)   : The target commit hash to submit the report.
        test_file_path (str): Path to test-results.json.
        project_type (str)  : server or client project.
        debug (bool)        : Enable or disable debug display.

    Returns:
        dict: Response status and message from Bitbucket (success or failed).
"""
def put_annotation(commit_hash, test_file_path, project_type, debug=False):    
    failure_result = extract_failure_details(test_file_path, project_type, debug)
    annotation_results = []

    for index, failure in enumerate(failure_result, start=1):
        # Build the Bitbucket annotation url
        # Path parameters should be followed the format below
        # https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}
        # example of pr_repo: https://api.bitbucket.org/2.0/repositories/VARLab/varlab-asset-store
        annotation_url = f'{pr_repo}/commit/{commit_hash}/reports/{project_type}-coverage-report/annotations/{ticket_number}-{index}'
        annotation = json.dumps({
            "external_id": f"{ticket_number}-{index}",
            "annotation_type": "VULNERABILITY",
            "path": failure["source_file"],
            "line": failure["line_number"],
            "summary": failure["test_name"],
            "details": failure["description"],
            "result": "FAILED",
            "severity": "HIGH",
            "created_on": datetime.now(timezone.utc).isoformat()
        })

        if debug:
            # Print the report format 
            print(f"\n\nNo.{index} Bitbucket Annotation API Form:")
            print(f"url: {annotation_url}")
            print(f"headers: {headers}")
            print(annotation)

        try:
            response = requests.put(annotation_url, data=annotation, headers=headers)
            response.raise_for_status()  # Raise an HTTPError exception if the status code is 4xx or 5xx
            annotation_results.append({"status": "success", "response": response.json()}) # Accumulate the success repsonding messages from Bitbucket for debugging

        except requests.exceptions.RequestException as e:
            error_message = {}

            # Check the request body information if the request object exists.
            if e.request:
                error_message["request_body"] = e.request.body

            # Process error messages if there is a response object
            if e.response:
                try:
                    error_message["error_response"] = e.response.json()
                except ValueError:
                    error_message["error_response"] = e.response.text  # If JSON parsing fails, treat as plain text
            else:
                error_message["error_response"] = "No response received."
            
            # Accumulate the failed repsonding messages from Bitbucket for debugging
            annotation_results.append({"status": "failed", "error": error_message})
        
    return annotation_results



def main(commit_hash, coverage_file_path, test_file_path, project_type, debug=False):
    """
    Main function of this file is to build the Bitbucket Code Coverage or Test Result Report form and
    create or update the PR report.
    """

    if debug:
        # Print Command Line Arguments
        print(f"Debug Info:")
        print(f"   - Commit: {commit_hash}")
        print(f"   - Coverage File: {coverage_file_path}")
        print(f"   - Test File: {test_file_path}")
        print(f"   - Report Type: {project_type}")

    # Create Bitbucket report API request
    report_api_result = create_report(commit_hash, coverage_file_path, test_file_path, project_type, debug)
    if debug:
        print("\n\nReport API Request Response:")
        if report_api_result.get("status") == "success":
            print("Status: SUCCESS")
            print(json.dumps(report_api_result.get("response", {}), indent=4))
        else:
            print("Status: FAILED")
            error_info = report_api_result.get("error", {})
            status_code = error_info.get("status_code", "N/A") 
            print(f"Error Code: {status_code}")
            print(json.dumps(error_info, indent=4))



    # Put annotations at the Bitbucket report
    annotation_api_results = put_annotation(commit_hash, test_file_path, project_type, debug)
    if debug:
        print("\n\nBitbucket Annotation API Request Response:")
        if annotation_api_results:
            for annotation_api_result in annotation_api_results:
                if annotation_api_result.get("status") == "failed":
                    print("Status: FAILED")
                    print(json.dumps(annotation_api_result.get("error", {}), indent=4))
                elif annotation_api_result.get("status") == "success":
                    print("Status: SUCCESS")
                    print(json.dumps(annotation_api_result.get("response", {}), indent=4))
        else:
            print("No annotations were processed.")


if __name__ == "__main__":
    # Parse arguments
    args = parser.parse_args()

    # Pass arguments to main() as parameters
    # Determine the type of report
    if args.server:
        main(args.commit, args.coverage_file_path, args.test_file_path, "server", args.debug)
    elif args.client:
        main(args.commit, args.coverage_file_path, args.test_file_path, "client", args.debug)



